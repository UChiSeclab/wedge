diff --git a/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java b/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java
index dc8190135bc5..91dc90799e72 100644
--- a/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java
+++ b/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java
@@ -42,6 +42,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
+import java.util.concurrent.ThreadPoolExecutor;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -901,8 +902,11 @@ private boolean shouldFetchMoreBlocks() {
      * namenode for more blocks. It terminates when it has dispatch enough block
      * move tasks or it has received enough blocks from the namenode, or the
      * elapsed time of the iteration has exceeded the max time limit.
+     *
+     * @param delay - time to sleep before sending getBlocks. Intended to
+     * disperse Balancer RPCs to NameNode for large clusters. See HDFS-11384.
      */
-    private void dispatchBlocks() {
+    private void dispatchBlocks(long delay) {
       this.blocksToReceive = 2 * getScheduledSize();
       long previousMoveTimestamp = Time.monotonicNow();
       while (getScheduledSize() > 0 && !isIterationOver()
@@ -927,15 +931,25 @@ private void dispatchBlocks() {
         if (shouldFetchMoreBlocks()) {
           // fetch new blocks
           try {
+            if(delay > 0) {
+              if (LOG.isDebugEnabled()) {
+                LOG.debug("Sleeping " + delay + "  msec.");
+              }
+              Thread.sleep(delay);
+            }
             final long received = getBlockList();
             if (received == 0) {
               return;
             }
             blocksToReceive -= received;
             continue;
+          } catch (InterruptedException ignored) {
+            // nothing to do
           } catch (IOException e) {
             LOG.warn("Exception while getting reportedBlock list", e);
             return;
+          } finally {
+            delay = 0L;
           }
         } else {
           // jump out of while-loop after the configured timeout.
@@ -1124,6 +1138,12 @@ public boolean dispatchAndCheckContinue() throws InterruptedException {
     return nnc.shouldContinue(dispatchBlockMoves());
   }
 
+  /**
+   * The best-effort limit on the number of RPCs per second
+   * the Balancer will send to the NameNode.
+   */
+  final static int BALANCER_NUM_RPC_PER_SEC = 20;
+
   /**
    * Dispatch block moves for each source. The thread selects blocks to move &
    * sends request to proxy source to initiate block move. The process is flow
@@ -1136,15 +1156,32 @@ private long dispatchBlockMoves() throws InterruptedException {
     final long bytesLastMoved = getBytesMoved();
     final Future<?>[] futures = new Future<?>[sources.size()];
 
+    int concurrentThreads = Math.min(sources.size(),
+        ((ThreadPoolExecutor)dispatchExecutor).getCorePoolSize());
+    assert concurrentThreads > 0 : "Number of concurrent threads is 0.";
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Balancer allowed RPCs per sec = " + BALANCER_NUM_RPC_PER_SEC);
+      LOG.debug("Balancer concurrent threads = " + concurrentThreads);
+      LOG.debug("Disperse Interval sec = " +
+          concurrentThreads / BALANCER_NUM_RPC_PER_SEC);
+    }
+    long dSec = 0;
     final Iterator<Source> i = sources.iterator();
     for (int j = 0; j < futures.length; j++) {
       final Source s = i.next();
+      final long delay = dSec * 1000;
       futures[j] = dispatchExecutor.submit(new Runnable() {
         @Override
         public void run() {
-          s.dispatchBlocks();
+          s.dispatchBlocks(delay);
         }
       });
+      // Calculate delay in seconds for the next iteration
+      if(j >= concurrentThreads) {
+        dSec = 0;
+      } else if((j + 1) % BALANCER_NUM_RPC_PER_SEC == 0) {
+        dSec++;
+      }
     }
 
     // wait for all dispatcher threads to finish
diff --git a/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/balancer/TestBalancer.java b/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/balancer/TestBalancer.java
index 30a3a327d8c3..e844b7fa0895 100644
--- a/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/balancer/TestBalancer.java
+++ b/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/balancer/TestBalancer.java
@@ -44,12 +44,14 @@
 import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_LAZY_PERSIST_FILE_SCRUB_INTERVAL_SEC;
 import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY;
 import static org.apache.hadoop.test.PlatformAssumptions.assumeNotWindows;
+import static org.junit.Assert.*;
 
 import org.apache.hadoop.hdfs.protocol.ErasureCodingPolicy;
+import org.apache.hadoop.hdfs.server.namenode.NameNodeRpcServer;
+import org.apache.hadoop.hdfs.server.protocol.NamenodeProtocol;
+import org.apache.hadoop.ipc.Server;
+import org.apache.hadoop.ipc.metrics.RpcMetrics;
 import org.junit.AfterClass;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
 
 import java.io.File;
 import java.io.IOException;
@@ -59,15 +61,7 @@
 import java.net.InetSocketAddress;
 import java.net.URI;
 import java.security.PrivilegedExceptionAction;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Properties;
-import java.util.Random;
-import java.util.Set;
+import java.util.*;
 import java.util.concurrent.TimeoutException;
 
 import org.apache.commons.lang.StringUtils;
@@ -793,6 +787,7 @@ private void doTest(Configuration conf, long[] capacities, String[] racks,
    *   file and then later read from the file.
    * @throws Exception
    */
+
   private void doTest(Configuration conf, long[] capacities,
       String[] racks, long newCapacity, String newRack, NewNodeInfo nodes,
       boolean useTool, boolean useFile) throws Exception {
@@ -808,6 +803,12 @@ private void doTest(Configuration conf, long[] capacities,
                                 .racks(racks)
                                 .simulatedCapacities(capacities)
                                 .build();
+
+
+    NameNodeRpcServer rpcServer = (NameNodeRpcServer) cluster.getNameNodeRpc();
+    NNRPCCallQueueLengthMonitor monitor = new NNRPCCallQueueLengthMonitor(rpcServer.getClientRpcServer());
+    Thread monitorThread = new Thread(monitor);
+
     try {
       cluster.waitActive();
       client = NameNodeProxies.createProxy(conf, cluster.getFileSystem(0).getUri(),
@@ -884,6 +885,8 @@ private void doTest(Configuration conf, long[] capacities,
         }
       }
 
+      monitorThread.start();
+
       // run balancer and validate results
       if (useTool) {
         runBalancerCli(conf, totalUsedSpace, totalCapacity, p, useFile, expectedExcludedNodes);
@@ -892,9 +895,61 @@ private void doTest(Configuration conf, long[] capacities,
       }
     } finally {
       cluster.shutdown();
+      monitor.stop();
+      monitorThread.join();
+    }
+  }
+
+  @Test
+  public void testBalancerDispatcherSurge() throws Exception {
+    HdfsConfiguration conf = new HdfsConfiguration();
+    initConf(conf);
+    int numDataNodes = 150;
+    long[] capacities = new long[numDataNodes];
+    String[] racks = new String[numDataNodes];
+    Arrays.fill(capacities, CAPACITY);
+    Arrays.fill(racks, RACK0);
+    doTest(conf, capacities, racks, CAPACITY/2,
+            RACK0, false);
+  }
+
+  public class NNRPCCallQueueLengthMonitor implements Runnable {
+    Server rpcServer;
+    boolean isRunning;
+    List<Integer> nNRPCCallQueueLengths;
+
+    public NNRPCCallQueueLengthMonitor(Server rpcServer) {
+      this.rpcServer = rpcServer;
+      this.isRunning = false;
+      this.nNRPCCallQueueLengths = new LinkedList<>();
+    }
+
+    @Override
+    public void run() {
+      RpcMetrics metrics = rpcServer.getRpcMetrics();
+      isRunning = true;
+      try {
+        while (isRunning) {
+          nNRPCCallQueueLengths.add(Integer.valueOf(metrics.callQueueLength()));
+          Thread.sleep(5);
+        }
+      } catch (InterruptedException e) {
+        e.printStackTrace();
+      }
+    }
+
+    public void stop () {
+      isRunning = false;
+      StringBuilder sb = new StringBuilder("NameNode RPC call queue length:");
+      for (int nNRPCCallQueueLength : nNRPCCallQueueLengths) {
+        sb.append(nNRPCCallQueueLength + " ");
+      }
+      sb.append("\n");
+      System.out.println(sb.toString());
     }
   }
 
+
   private void runBalancer(Configuration conf, long totalUsedSpace,
       long totalCapacity) throws Exception {
     runBalancer(conf, totalUsedSpace, totalCapacity,
