/* line 1 */ import java.io.OutputStream;
/* line 2 */ import java.io.IOException;
/* line 3 */ import java.io.InputStream;
/* line 4 */ import java.io.PrintWriter;
/* line 5 */ import java.util.Arrays;
/* line 6 */ import java.util.List;
/* line 7 */ import java.util.InputMismatchException;
/* line 8 */ import java.io.IOException;
/* line 9 */ import java.util.Comparator;
/* line 10 */ import java.io.InputStream;
/* line 11 */ import java.util.ArrayList;
/* line 12 */ 
/* line 13 */ /**
/* line 14 */  * Built using CHelper plug-in
/* line 15 */  * Actual solution is at the top
/* line 16 */  *
/* line 17 */  * @author Pradyumn
/* line 18 */  */
/* line 19 NOT_COVERED */ public class Main {
/* line 20 */     public static void main(String[] args) {
/* line 21 COVERED, hit count: 1 */         InputStream inputStream = System.in;
/* line 22 COVERED, hit count: 1 */         OutputStream outputStream = System.out;
/* line 23 COVERED, hit count: 1 */         FastReader in = new FastReader(inputStream);
/* line 24 COVERED, hit count: 1 */         PrintWriter out = new PrintWriter(outputStream);
/* line 25 COVERED, hit count: 1 */         TaskE solver = new TaskE();
/* line 26 COVERED, hit count: 1 */         solver.solve(1, in, out);
/* line 27 COVERED, hit count: 1 */         out.close();
/* line 28 COVERED, hit count: 1 */     }
/* line 29 */ 
/* line 30 COVERED, hit count: 1 */     static class TaskE {
/* line 31 COVERED, hit count: 29 */         static Comparator<TaskE.Segment> comparatorXY = new Comparator<TaskE.Segment>() {
/* line 32 */ 
/* line 33 */             public int compare(TaskE.Segment o1, TaskE.Segment o2) {
/* line 34 COVERED, hit count: 28 */                 if (o1.x1 != o2.x1)
/* line 35 COVERED, hit count: 28 */                     return o1.x1 - o2.x1;
/* line 36 NOT_COVERED */                 return o1.y1 - o2.y1;
/* line 37 */             }
/* line 38 */         };
/* line 39 COVERED, hit count: 29 */         static Comparator<TaskE.Segment> comparatorYX = new Comparator<TaskE.Segment>() {
/* line 40 */ 
/* line 41 */             public int compare(TaskE.Segment o1, TaskE.Segment o2) {
/* line 42 COVERED, hit count: 28 */                 if (o1.y1 != o2.y1)
/* line 43 COVERED, hit count: 28 */                     return o1.y1 - o2.y1;
/* line 44 NOT_COVERED */                 return o1.x1 - o2.x1;
/* line 45 */             }
/* line 46 */         };
/* line 47 */ 
/* line 48 */         public void solve(int testNumber, FastReader in, PrintWriter out) {
/* line 49 COVERED, hit count: 1 */             int n = in.nextInt();
/* line 50 COVERED, hit count: 1 */             int m = in.nextInt();
/* line 51 COVERED, hit count: 1 */             TaskE.Point[] blue = new TaskE.Point[n];
/* line 52 COVERED, hit count: 1 */             TaskE.Point[] red = new TaskE.Point[m];
/* line 53 PARTIALLY_COVERED, hit count: 3 */             for (int i = 0; i < n; ++i) {
/* line 54 COVERED, hit count: 2 */                 blue[i] = new TaskE.Point(in.nextInt(), in.nextInt());
/* line 55 */             }
/* line 56 PARTIALLY_COVERED, hit count: 3 */             for (int i = 0; i < m; ++i) {
/* line 57 COVERED, hit count: 2 */                 red[i] = new TaskE.Point(in.nextInt(), in.nextInt());
/* line 58 */             }
/* line 59 COVERED, hit count: 1 */             int high = 123456789;
/* line 60 COVERED, hit count: 1 */             int low = 0;
/* line 61 PARTIALLY_COVERED, hit count: 28 */             while (high - low > 1) {
/* line 62 COVERED, hit count: 27 */                 int mid = (high + low) >>> 1;
/* line 63 PARTIALLY_COVERED, hit count: 27 */                 if (ok(blue, red, mid))
/* line 64 COVERED, hit count: 25 */                     high = mid;
/* line 65 */                 else
/* line 66 COVERED, hit count: 2 */                     low = mid;
/* line 67 COVERED, hit count: 27 */             }
/* line 68 COVERED, hit count: 1 */             if (ok(blue, red, high))
/* line 69 COVERED, hit count: 1 */                 out.println(high);
/* line 70 */             else
/* line 71 NOT_COVERED */                 out.println("Poor Sereja!");
/* line 72 COVERED, hit count: 1 */         }
/* line 73 */ 
/* line 74 */         private boolean ok(TaskE.Point[] b, TaskE.Point[] r, int d) {
/* line 75 COVERED, hit count: 28 */             int n = b.length;
/* line 76 COVERED, hit count: 28 */             int m = r.length;
/* line 77 COVERED, hit count: 28 */             TaskE.Segment[] blue = new TaskE.Segment[n];
/* line 78 COVERED, hit count: 28 */             TaskE.Segment[] red = new TaskE.Segment[m];
/* line 79 COVERED, hit count: 28 */             TaskE.Segment[] blueMerged = new TaskE.Segment[n];
/* line 80 COVERED, hit count: 28 */             TaskE.Segment[] redMerged = new TaskE.Segment[m];
/* line 81 COVERED, hit count: 28 */             int nb = 0, nr = 0;
/* line 82 PARTIALLY_COVERED, hit count: 84 */             for (int i = 0; i < n; ++i) {
/* line 83 COVERED, hit count: 56 */                 blue[i] = new TaskE.Segment();
/* line 84 COVERED, hit count: 56 */                 blue[i].x1 = blue[i].x2 = b[i].x;
/* line 85 COVERED, hit count: 56 */                 blue[i].y1 = b[i].y - 2 * d;
/* line 86 COVERED, hit count: 56 */                 blue[i].y2 = b[i].y + 2 * d;
/* line 87 */             }
/* line 88 PARTIALLY_COVERED, hit count: 84 */             for (int i = 0; i < m; ++i) {
/* line 89 COVERED, hit count: 56 */                 red[i] = new TaskE.Segment();
/* line 90 COVERED, hit count: 56 */                 red[i].y1 = red[i].y2 = r[i].y;
/* line 91 COVERED, hit count: 56 */                 red[i].x1 = r[i].x - 2 * d;
/* line 92 COVERED, hit count: 56 */                 red[i].x2 = r[i].x + 2 * d;
/* line 93 */             }
/* line 94 COVERED, hit count: 28 */             Arrays.sort(blue, comparatorXY);
/* line 95 COVERED, hit count: 28 */             Arrays.sort(red, comparatorYX);
/* line 96 PARTIALLY_COVERED, hit count: 84 */             for (int i = 0; i < n; ++i) {
/* line 97 PARTIALLY_COVERED, hit count: 56 */                 if (i == 0 || !blueMerged[nb - 1].hasCommonPoint(blue[i])) blueMerged[nb++] = blue[i];
/* line 98 NOT_COVERED */                 else blueMerged[nb - 1].union(blue[i]);
/* line 99 */             }
/* line 100 PARTIALLY_COVERED, hit count: 84 */             for (int i = 0; i < m; ++i) {
/* line 101 PARTIALLY_COVERED, hit count: 56 */                 if (i == 0 || !redMerged[nr - 1].hasCommonPoint(red[i])) redMerged[nr++] = red[i];
/* line 102 NOT_COVERED */                 else redMerged[nr - 1].union(red[i]);
/* line 103 */             }
/* line 104 COVERED, hit count: 28 */             boolean[][] isConnected = new boolean[nb][nb];
/* line 105 PARTIALLY_COVERED, hit count: 58 */             for (int i = 0; i < nr; ++i) {
/* line 106 COVERED, hit count: 56 */                 List<Integer> touched = new ArrayList<>();
/* line 107 PARTIALLY_COVERED, hit count: 168 */                 for (int j = 0; j < nb; ++j) {
/* line 108 PARTIALLY_COVERED, hit count: 112 */                     if (redMerged[i].hasCommonPoint(blueMerged[j])) touched.add(j);
/* line 109 */                 }
/* line 110 PARTIALLY_COVERED, hit count: 111 */                 for (int j = 0; j < touched.size(); ++j) {
/* line 111 PARTIALLY_COVERED, hit count: 108 */                     for (int k = j + 1; k < touched.size(); ++k) {
/* line 112 COVERED, hit count: 53 */                         int aa = touched.get(j);
/* line 113 COVERED, hit count: 53 */                         int bb = touched.get(k);
/* line 114 PARTIALLY_COVERED, hit count: 53 */                         if (isConnected[aa][bb] || isConnected[bb][aa]) return true;
/* line 115 COVERED, hit count: 27 */                         isConnected[aa][bb] = isConnected[bb][aa] = true;
/* line 116 */                     }
/* line 117 */                 }
/* line 118 */             }
/* line 119 COVERED, hit count: 2 */             return false;
/* line 120 */         }
/* line 121 */ 
/* line 122 */         static class Point {
/* line 123 */             int x;
/* line 124 */             int y;
/* line 125 */ 
/* line 126 COVERED, hit count: 4 */             public Point(int xx, int yy) {
/* line 127 COVERED, hit count: 4 */                 x = xx + yy;
/* line 128 COVERED, hit count: 4 */                 y = xx - yy;
/* line 129 COVERED, hit count: 4 */             }
/* line 130 */ 
/* line 131 */         }
/* line 132 */ 
/* line 133 */         static class Segment {
/* line 134 */             int x1;
/* line 135 */             int y1;
/* line 136 */             int x2;
/* line 137 */             int y2;
/* line 138 */ 
/* line 139 COVERED, hit count: 112 */             public Segment() {
/* line 140 */ 
/* line 141 COVERED, hit count: 112 */             }
/* line 142 */ 
/* line 143 NOT_COVERED */             public Segment(int xx1, int yy1, int xx2, int yy2) {
/* line 144 NOT_COVERED */                 x1 = xx1;
/* line 145 NOT_COVERED */                 y1 = yy1;
/* line 146 NOT_COVERED */                 x2 = xx2;
/* line 147 NOT_COVERED */                 y2 = yy2;
/* line 148 NOT_COVERED */             }
/* line 149 */ 
/* line 150 */             boolean hasCommonPoint(TaskE.Segment segment) {
/* line 151 PARTIALLY_COVERED, hit count: 168 */                 if (x1 > segment.x2) return false;
/* line 152 PARTIALLY_COVERED, hit count: 166 */                 if (x2 < segment.x1) return false;
/* line 153 PARTIALLY_COVERED, hit count: 137 */                 if (y1 > segment.y2) return false;
/* line 154 PARTIALLY_COVERED, hit count: 136 */                 if (y2 < segment.y1) return false;
/* line 155 COVERED, hit count: 107 */                 return true;
/* line 156 */             }
/* line 157 */ 
/* line 158 */             void union(TaskE.Segment s) {
/* line 159 NOT_COVERED */                 x1 = Math.min(x1, s.x1);
/* line 160 NOT_COVERED */                 x2 = Math.max(x2, s.x2);
/* line 161 NOT_COVERED */                 y1 = Math.min(y1, s.y1);
/* line 162 NOT_COVERED */                 y2 = Math.max(y2, s.y2);
/* line 163 NOT_COVERED */             }
/* line 164 */ 
/* line 165 */         }
/* line 166 */ 
/* line 167 */     }
/* line 168 */ 
/* line 169 */     static class FastReader {
/* line 170 */         private InputStream stream;
/* line 171 COVERED, hit count: 1 */         private byte[] buf = new byte[8192];
/* line 172 */         private int curChar;
/* line 173 */         private int pnumChars;
/* line 174 */ 
/* line 175 COVERED, hit count: 1 */         public FastReader(InputStream stream) {
/* line 176 COVERED, hit count: 1 */             this.stream = stream;
/* line 177 COVERED, hit count: 1 */         }
/* line 178 */ 
/* line 179 */         private int pread() {
/* line 180 COVERED, hit count: 20 */             if (pnumChars == -1) {
/* line 181 NOT_COVERED */                 throw new InputMismatchException();
/* line 182 */             }
/* line 183 PARTIALLY_COVERED, hit count: 20 */             if (curChar >= pnumChars) {
/* line 184 COVERED, hit count: 1 */                 curChar = 0;
/* line 185 */                 try {
/* line 186 COVERED, hit count: 1 */                     pnumChars = stream.read(buf);
/* line 187 NOT_COVERED */                 } catch (IOException e) {
/* line 188 NOT_COVERED */                     throw new InputMismatchException();
/* line 189 COVERED, hit count: 1 */                 }
/* line 190 COVERED, hit count: 1 */                 if (pnumChars <= 0) {
/* line 191 NOT_COVERED */                     return -1;
/* line 192 */                 }
/* line 193 */             }
/* line 194 COVERED, hit count: 20 */             return buf[curChar++];
/* line 195 */         }
/* line 196 */ 
/* line 197 */         public int nextInt() {
/* line 198 COVERED, hit count: 10 */             int c = pread();
/* line 199 COVERED, hit count: 10 */             while (isSpaceChar(c))
/* line 200 NOT_COVERED */                 c = pread();
/* line 201 COVERED, hit count: 10 */             int sgn = 1;
/* line 202 COVERED, hit count: 10 */             if (c == '-') {
/* line 203 NOT_COVERED */                 sgn = -1;
/* line 204 NOT_COVERED */                 c = pread();
/* line 205 */             }
/* line 206 COVERED, hit count: 10 */             int res = 0;
/* line 207 */             do {
/* line 208 COVERED, hit count: 10 */                 if (c == ',') {
/* line 209 NOT_COVERED */                     c = pread();
/* line 210 */                 }
/* line 211 COVERED, hit count: 10 */                 if (c < '0' || c > '9') {
/* line 212 NOT_COVERED */                     throw new InputMismatchException();
/* line 213 */                 }
/* line 214 COVERED, hit count: 10 */                 res *= 10;
/* line 215 COVERED, hit count: 10 */                 res += c - '0';
/* line 216 COVERED, hit count: 10 */                 c = pread();
/* line 217 COVERED, hit count: 10 */             } while (!isSpaceChar(c));
/* line 218 COVERED, hit count: 10 */             return res * sgn;
/* line 219 */         }
/* line 220 */ 
/* line 221 */         private boolean isSpaceChar(int c) {
/* line 222 PARTIALLY_COVERED, hit count: 20 */             return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
/* line 223 */         }
/* line 224 */ 
/* line 225 */     }
/* line 226 */ }
/* line 227 */ 