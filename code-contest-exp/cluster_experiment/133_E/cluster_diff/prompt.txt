Problem Statement
A lot of people associate Logo programming language with turtle graphics. In this case the turtle moves along the straight line and accepts commands "T" ("turn around") and "F" ("move 1 unit forward").

You are given a list of commands that will be given to the turtle. You have to change exactly n commands from the list (one command can be changed several times). How far from the starting point can the turtle move after it follows all the commands of the modified list?

Input

The first line of input contains a string commands — the original list of commands. The string commands contains between 1 and 100 characters, inclusive, and contains only characters "T" and "F".

The second line contains an integer n (1 ≤ n ≤ 50) — the number of commands you have to change in the list.

Output

Output the maximum distance from the starting point to the ending point of the turtle's path. The ending point of the turtle's path is turtle's coordinate after it follows all the commands of the modified list.

Examples

Input

FT
1


Output

2


Input

FFFTFFF
2


Output

6

Note

In the first example the best option is to change the second command ("T") to "F" — this way the turtle will cover a distance of 2 units.

In the second example you have to change two commands. One of the ways to cover maximal distance of 6 units is to change the fourth command and first or last one.
------------------------------
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.StringTokenizer;

public class magic2 {
	static char[] input;
	static int[][][] memo;
	public static void main(String[] args) throws Exception {
		FasterScanner sc = new FasterScanner();
		PrintWriter out = new PrintWriter(System.out);
		input = sc.next().toCharArray();
		int N = sc.nextInt();
		memo = new int[input.length][2][N+1];
		for(int[][] x : memo)
			for(int[] y : x)
				Arrays.fill(y,987654321);
		int ans = 0;
		for(int a=N;a>=0;a-=2){
			ans = Math.max(ans,DP(0,0,a));
			ans = Math.max(ans,DP(0,1,a));
		}
		out.println(ans);
		out.close();
	}

	private static int DP(int pos, int dir, int changes) {
		if(changes<0)return -987654;
		if(pos==input.length){
			if(changes==0)return 0;
			return -987654;
		}
		if(memo[pos][dir][changes]!=987654321)return memo[pos][dir][changes];
		int change = 1;
		if(dir==0)change = -1;
		int ans = -987654321;
		if(input[pos]=='F'){
			//forward
			ans=Math.max(ans,change+DP(pos+1,dir,changes));
			ans=Math.max(ans,DP(pos+1,1-dir,changes-1));
		}
		else{
			//turn
			ans=Math.max(ans,DP(pos+1,1-dir,changes));
			ans=Math.max(ans,change+DP(pos+1,dir,changes-1));
		}
		return memo[pos][dir][changes]=ans;
	}

	private static int fix(char c) {
		if(c=='S')return 0;
		return c-'a'+1;
	}

	static class FasterScanner{
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;
		
		public FasterScanner(){
			stream = System.in;
		}
		int read(){
			if(numChars==-1)
				throw new InputMismatchException();
			if(curChar>=numChars){
				curChar = 0;
				try{
					numChars = stream.read(buf);
				} catch (IOException e){
					throw new InputMismatchException();
				}
				if(numChars <= 0)
					return -1;
			}
			return buf[curChar++];
		}
		
		boolean isSpaceChar(int c){
			return c==' '||c=='\n'||c=='\r'||c=='\t'||c==-1;
		}
		boolean isEndline(int c){
			return c=='\n'||c=='\r'||c==-1;
		}
		int nextInt(){
			return Integer.parseInt(next());
		}
		long nextLong(){
			return Long.parseLong(next());
		}
		double nextDouble(){
			return Double.parseDouble(next());
		}
		String next(){
			int c = read();
			while(isSpaceChar(c))
				c=read();
			StringBuilder res = new StringBuilder();
			do{
				res.appendCodePoint(c);
				c=read();
			} while(!isSpaceChar(c));
			return res.toString();
		}
		String nextLine(){
			int c = read();
			while(isEndline(c))
				c=read();
			StringBuilder res = new StringBuilder();
			do{
				res.appendCodePoint(c);
				c = read();
			}while(!isEndline(c));
			return res.toString();
		}
		
	}
	static class FastScanner {
		BufferedReader br;
		StringTokenizer st;

		public FastScanner(InputStream in) throws Exception {
			br = new BufferedReader(new InputStreamReader(in));
			st = new StringTokenizer(br.readLine().trim());
		}

		public int numTokens() throws Exception {
			if (!st.hasMoreTokens()) {
				st = new StringTokenizer(br.readLine().trim());
				return numTokens();
			}
			return st.countTokens();
		}

		public boolean hasNext() throws Exception {
			if (!st.hasMoreTokens()) {
				st = new StringTokenizer(br.readLine().trim());
				return hasNext();
			}
			return true;
		}

		public String next() throws Exception {
			if (!st.hasMoreTokens()) {
				st = new StringTokenizer(br.readLine().trim());
				return next();
			}
			return st.nextToken();
		}

		public double nextDouble() throws Exception {
			return Double.parseDouble(next());
		}

		public float nextFloat() throws Exception {
			return Float.parseFloat(next());
		}

		public long nextLong() throws Exception {
			return Long.parseLong(next());
		}

		public int nextInt() throws Exception {
			return Integer.parseInt(next());
		}

		public String nextLine() throws Exception {
			return br.readLine();
		}
	}

}

------------------------------
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class R96D2_E {
    static String inp;
    static int n;
    static int st;
    static int DP[][][][];
    
    public static int call(int i, int rem, int pos, int add) {
        if (i == n && (rem%2==0))
            return Math.abs(pos);
        if (i == n)
            return -1000000;
        if (pos == 0 && add == -1)
            add = 1;
        int d = add==-1?1:0;
        if(DP[i][rem][pos][d]!=-1)
            return DP[i][rem][pos][d];
        if (rem == 0) {
            if (inp.charAt(i) == 'F')
                return DP[i][rem][pos][d] = call(i + 1, rem, pos + add, add);
            else
                return DP[i][rem][pos][d] = call(i + 1, rem, pos, add * -1);
        } else {
            int res = 0;
            for (int j = 0; j <= rem; j++) {
                if ((inp.charAt(i) == 'F' && j % 2 == 0)
                        || (inp.charAt(i) == 'T' && j % 2 == 1))
                    res = Math.max(res, call(i + 1, rem - j, pos + add, add));
                else
                    res = Math.max(res, call(i + 1, rem - j, pos, -1 * add));
            }
            return DP[i][rem][pos][d] = res;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        // int n = Integer.parseInt(in.readLine());
        // String []s = in.readLine().split(" ");
        inp = in.readLine();
        n = inp.length();
        st = Integer.parseInt(in.readLine());
        DP = new int [n][st+1][n+2][2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < st+1; j++) {
                for (int j2 = 0; j2 < n+2; j2++) {
                    for (int k = 0; k < 2; k++) {
                        DP[i][j][j2][k] = -1;
                    }
                }
            }
        }
        System.out.println(call(0, st, 0, 1));
    }
}

------------------------------
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.StringTokenizer;


public class cf132c {
  static int n,m,oo=987654321;;
  static String v;
  static Integer[][][] memo;
  public static void main(String[] args) {
    FastIO in = new FastIO(), out = in;
    v = in.next().trim();
    n = in.nextInt();
    m = v.length();
    memo = new Integer[2][m][n+1];
    out.println(Math.max(go(0,n,0),go(0,n,1)));
    out.close();
  }
  static int go(int pos, int left, int dir) {
    if(left < 0) return -oo;
    if(pos == m) {
      return left%2==0?0:-oo;
    }
    if(memo[dir][pos][left] != null)
      return memo[dir][pos][left];
    int ans = -oo;
    char comm = v.charAt(pos);
    ans = Math.max(ans, go(pos+1,left-(comm=='T'?0:1),1-dir));
    ans = Math.max(ans, 2*dir-1 + go(pos+1,left-(comm=='F'?0:1),dir));
    return memo[dir][pos][left] = ans;
  }
  static class FastIO extends PrintWriter {
    BufferedReader br;
    StringTokenizer st;
    
    public FastIO() {
      this(System.in,System.out);
    }
    public FastIO(InputStream in, OutputStream out) {
      super(new BufferedWriter(new OutputStreamWriter(out)));
      br = new BufferedReader(new InputStreamReader(in));
      scanLine();
    }
    public void scanLine() {
      try {
        st = new StringTokenizer(br.readLine().trim());
      } catch(Exception e) {
        throw new RuntimeException(e.getMessage());
      }
    }
    public int numTokens() {
      if(!st.hasMoreTokens()) {
        scanLine();
        return numTokens();
      }
      return st.countTokens();
    }
    public String next() {
      if(!st.hasMoreTokens()) {
        scanLine();
        return next();
      }
      return st.nextToken();
    }
    public double nextDouble() {
      return Double.parseDouble(next());
    }
    public long nextLong() {
      return Long.parseLong(next());
    }
    public int nextInt() {
      return Integer.parseInt(next());
    }
  }
}

------------------------------
import java.util.Scanner;
import java.io.OutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Fantast
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		Scanner in = new Scanner(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskE solver = new TaskE();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskE {
    int n;
    char[] s;
    public void solve(int testNumber, Scanner in, PrintWriter out) {
        s = in.next().toCharArray();
        n = in.nextInt();

        for (int i = 0; i < 101; ++i) {
            for (int j = 0; j < 2; ++j) {
                for (int k = 0; k < 101; ++k) {
                    mxs[i][j][k] = -1;
                    mns[i][j][k] = -1;
                }
            }
        }

        out.println(
                mx(
                        Math.abs(mxdist(0, 1, n)),
                        Math.abs(mndist(0, 1, n)),
                        Math.abs(mxdist(0, -1, n)),
                        Math.abs(mndist(0, -1, n))
                ));
    }

    private int mx(int... a) {
        int res = a[0];
        for (int n : a) {
            res = Math.max(res, n);
        }
        return res;
    }

    int mxs[][][] = new int[101][2][101];
    public int mxdist(int ind, int dir, int tochange) {
        if (ind == s.length) {
            if (tochange > s.length - ind) {
                return Integer.MIN_VALUE / 2;
            }
            return 0;
        }

        int di = (dir+1)/2;
        if (mxs[ind][di][tochange] != -1) {
            return mxs[ind][di][tochange];
        }

        int res;
        if (s[ind] == 'T') {
            res = Integer.MIN_VALUE / 2;
            for (int dc = 0; dc <= tochange; ++dc) {
                if (dc%2 == 0) {
                    res = Math.max(res, mxdist(ind + 1, -dir, tochange - dc));
                } else {
                    res = Math.max(res, dir + mxdist(ind + 1, dir, tochange - dc));
                }
            }
        } else {
            res = Integer.MIN_VALUE / 2;
            for (int dc = 0; dc <= tochange; ++dc) {
                if (dc%2 == 0) {
                    res = Math.max(res, dir + mxdist(ind + 1, dir, tochange - dc));
                } else {
                    res = Math.max(res, mxdist(ind + 1, -dir, tochange - dc));
                }
            }
        }

        return mxs[ind][di][tochange] = res;
    }

    int mns[][][] = new int[101][2][101];
    public int mndist(int ind, int dir, int tochange) {
        if (ind == s.length) {
            if (tochange > s.length - ind) {
                return Integer.MAX_VALUE / 2;
            }
            return 0;
        }

        int di = (dir+1)/2;
        if (mns[ind][di][tochange] != -1) {
            return mns[ind][di][tochange];
        }

        int res;
        if (s[ind] == 'T') {
            res = Integer.MAX_VALUE / 2;
            for (int dc = 0; dc <= tochange; ++dc) {
                if (dc%2 == 0) {
                    res = Math.min(res, mndist(ind + 1, -dir, tochange - dc));
                } else {
                    res = Math.min(res, dir + mndist(ind + 1, dir, tochange - dc));
                }
            }
        } else {
            res = Integer.MAX_VALUE / 2;
            for (int dc = 0; dc <= tochange; ++dc) {
                if (dc%2 == 0) {
                    res = Math.min(res, dir + mndist(ind + 1, dir, tochange - dc));
                } else {
                    res = Math.min(res, mndist(ind + 1, -dir, tochange - dc));
                }
            }
        }
        return mns[ind][di][tochange] = res;
    }
}


------------------------------
import java.util.Arrays;
import java.util.Scanner;


public class CF133E {

    final static int UNDEF = 1000000;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String commands = sc.next();
        int n = sc.nextInt();
        
        int[][][][] dp = new int[commands.length()+1][n+1][201][2];
        for (int[][][] is : dp) {
            for (int[][] is2 : is) {
                for (int[] is3 : is2) {
                    Arrays.fill(is3, UNDEF);
                }
            }
        }
        dp[0][0][100][0] = 0;
        for (int i = 1; i < dp.length; i++) {
            boolean commandIsT = commands.charAt(i-1) == 'T';
            for (int j = 0; j < n+1; j++) {
                for (int k = 0; k <= 200; k++) {
                    for (int l = 0; l < 2; l++) {
                        int dx = l == 0 ? -1 : 1;
                        if (commandIsT) {
                            if(dp[i-1][j][k][l] != UNDEF) {
                                dp[i][j][k][(l+1)%2] = getBigger(dp[i-1][j][k][l], dp[i][j][k][(l+1)%2]);
                            }
                            if(j > 0 && dp[i-1][j-1][k][l] != UNDEF) {
                                dp[i][j][k+dx][l] = getBigger(dp[i-1][j-1][k][l] + dx, dp[i][j][k+dx][l]);
                            }
                        }
                        else {
                            if(dp[i-1][j][k][l] != UNDEF) {
                                dp[i][j][k+dx][l] = getBigger(dp[i-1][j][k][l] + dx, dp[i][j][k+dx][l]);
                            }
                            if(j > 0 && dp[i-1][j-1][k][l] != UNDEF) {
                                dp[i][j][k][(l+1)%2] = getBigger(dp[i-1][j-1][k][l], dp[i][j][k][(l+1)%2]);
                            }
                        }
                        if(j > 1) dp[i][j][k][l] = getBigger(dp[i][j-2][k][l], dp[i][j][k][l]);
                    }
                }
            }
        }
        int max = 0;
        for (int i = 0; i <= 200; i++) {
            for (int j = 0; j < 2; j++) {
                if(dp[commands.length()][n][i][j] != UNDEF)
                    max = Math.max(max, Math.abs(dp[commands.length()][n][i][j]));                
            }
        }
        System.out.println(max);
    }
    
    static int getBigger(int a, int b) {
        if (a == UNDEF) return b;
        if (b == UNDEF) return a;
        return Math.abs(a) > Math.abs(b) ? a : b;
    }

}

------------------------------


Write a python script that can generate test cases for a programming problem with the provided problem statement and solution codes. The test case should be focus on exhausting the code to get time limit exceeded and should follow the input format. The python script should be able to read an argument which specify a directory and write all the testcases as 'test_01.in', 'test_02.in', ... into the directory.