Problem Statement
On the competitive programming platform CodeCook, every person has a rating graph described by an array of integers a of length n. You are now updating the infrastructure, so you've created a program to compress these graphs.

The program works as follows. Given an integer parameter k, the program takes the minimum of each contiguous subarray of length k in a.

More formally, for an array a of length n and an integer k, define the k-compression array of a as an array b of length n-k+1, such that $$$b_j =min_{j≤ i≤ j+k-1}a_i$$$

For example, the 3-compression array of [1, 3, 4, 5, 2] is [min\{1, 3, 4\}, min\{3, 4, 5\}, min\{4, 5, 2\}]=[1, 3, 2].

A permutation of length m is an array consisting of m distinct integers from 1 to m in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (m=3 but there is 4 in the array).

A k-compression array will make CodeCook users happy if it will be a permutation. Given an array a, determine for all 1≤ k≤ n if CodeCook users will be happy after a k-compression of this array or not.

Input

The first line contains a single integer t (1≤ t≤ 10^4) — the number of test cases.

The first line of the description of each test case contains a single integer n (1≤ n≤ 3⋅ 10^5) — the length of the array.

The second line of the description of each test case contains n integers a_1,…,a_n (1≤ a_i≤ n) — the elements of the array.

It is guaranteed, that the sum of n for all test cases does not exceed 3⋅ 10^5.

Output

For each test case, print a binary string of length n. 

The k-th character of the string should be 1 if CodeCook users will be happy after a k-compression of the array a, and 0 otherwise. 

Example

Input


5
5
1 5 3 4 2
4
1 3 2 1
5
1 3 3 3 2
10
1 2 3 4 5 6 7 8 9 10
3
3 3 2


Output


10111
0001
00111
1111111111
000

Note

In the first test case, a=[1, 5, 3, 4, 2].

  * The 1-compression of a is [1, 5, 3, 4, 2] and it is a permutation. 
  * The 2-compression of a is [1, 3, 3, 2] and it is not a permutation, since 3 appears twice. 
  * The 3-compression of a is [1, 3, 2] and it is a permutation. 
  * The 4-compression of a is [1, 2] and it is a permutation. 
  * The 5-compression of a is [1] and it is a permutation. 
------------------------------
import java.util.*;
import java.io.*;
import java.lang.*;

public class B {
    static class FastReader {
            BufferedReader  br;
            StringTokenizer st;
        
            public FastReader() {
              br = new BufferedReader(new InputStreamReader(System.in));
            }
        
            String next() {
              while (st == null || !st.hasMoreElements()) {
                try {
                  st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                  e.printStackTrace();
                }
              }
              return st.nextToken();
            }
        
            int nextInt() {
              return Integer.parseInt(next());
            }
        
            long nextLong() {
              return Long.parseLong(next());
            }
        
            double nextDouble() {
              return Double.parseDouble(next());
            }
        
            String nextLine() {
              String str = "";
              try {
                str = br.readLine();
              } catch (IOException e) {
                e.printStackTrace();
              }
              return str;
            }
          }
         static  FastReader sc=new FastReader();
    public static void main(String[] args) throws Exception {
          int t=sc.nextInt();
          while(t-->0)
      B.go();   
          }



                    
    static void go() {
      int n=sc.nextInt();
      int a[]=new int[n];
      for(int i=0;i<n;i++){
        a[i]=sc.nextInt();
      }
      int b[]=a.clone();
      sort(b);
      StringBuilder ans=new StringBuilder("");
      int low=n;
      for(int i=0;i<n;i++){
          if(b[i]!=(i+1)){
            low=i;
            break;
          }
      }
      if(low==n){
        ans.append(1);
      }else{
      for(int i=n;i>low;i--){
        ans.append(0);

      }
    }
    int min=Integer.MAX_VALUE;
    for(int i=1;i<n-1;i++){
      if(a[i-1]>a[i]&&a[i]<a[i+1]){
        min=Math.min(min,a[i]);
      }
    }
    if(min==Integer.MAX_VALUE){
      if(low==n){
        for(int i=n-1;i>0;i--){
           ans.append(1);
        }
      }else{
        for(int i=low;i>0;i--){
         ans.append(1);
        }
      }
    }else{
      if(low==n){
        for(int i=n-1;i>min;i--){
         ans.append(0);
        }
      }else{
        for(int i=low;i>min;i--){
       ans.append(0);
        }
      }
      for(int i=Math.min(min,low);i>=1;i--){
         ans.append(1);
      }
    }
    System.out.println(ans);
    }
  static  void sort(int [] a) {
         ArrayList<Integer> aa = new ArrayList<>();
         for (int i : a) {
      aa.add(i);}
         Collections.sort(aa);
            for (int i = 0; i < a.length; i++)a[i] = aa.get(i);
              }
  
  }


------------------------------

import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class C {
	static BufferedReader br;
	static int cin() throws Exception
	{
		return Integer.valueOf(br.readLine());
	}
	static int[] split() throws Exception
	{
		String[] cmd=br.readLine().split(" ");
		int[] ans=new int[cmd.length];
		for(int i=0;i<cmd.length;i++)
		{
			ans[i]=Integer.valueOf(cmd[i]);
		}
		return ans;
	}
	static long p=1000000007;
	static long power(long x, long y) 
    { 
        long res = 1;      
        x = x % p;  
       if (x == 0) return 0;
        while (y > 0) 
        { 
            if((y & 1)==1) 
                res = (res * x) % p; 
            y = y >> 1;  
            x = (x * x) % p;  
        } 
        return res; 
    } 
	public static void main(String[] args) throws Exception{
		// TODO Auto-generated method stub
		br=new BufferedReader(new InputStreamReader(System.in));
		int cases=cin();
		while(cases!=0)
		{
			cases--;
			int n=cin();
			int[]arr=split();
			seg_tree seg=new seg_tree(n,arr);
			seg.build_segment_tree(1, 0, n-1);
			int[]ans=new int[n];
			if(seg.rmq(0, n-1)==1)
				ans[n-1]=1;
			int[]check=new int[n+1];
			for(int i=0;i<n;i++)
			{
				check[arr[i]]=1;
			}
			boolean flag=true;
			for(int i=1;i<=n;i++)
			{
				if(check[i]==0)
				{
					flag=false;
					break;
				}
			}
			if(flag)
				ans[0]=1;
			int ind=0;
			int l=0;
			int r=n-1;
			for(int i=0;i<n;i++)
			{
				if(arr[l]==(i+1))
					l++;
				else if(arr[r]==(i+1))
					r--;
				else
				{
					ind=i+1;
					break;
				}
				if(seg.rmq(l,r)!=(i+2))
				{
					ind=i+1;
					break;
				}
			}
			//System.out.println(ind);
			for(int i=2;i<=Math.min(n-ind,n-1);i++)
			{
				ans[i-1]=0;
			}
			for(int i=n-ind;i<n-1;i++)
			{
				ans[i]=1;
			}
			for(int i=0;i<n;i++)
			{
				System.out.print(ans[i]);
			}
			System.out.println();
		}
	}
}
class seg_tree {
	static int len=0;
	static int[] a;
	static int[] segment_tree;
	static int d=0;
	public seg_tree(int n,int[]arr)
	{
		this.len=n;
		this.a=arr;
		this.segment_tree=new int[4*n+1];
	}
	static int left(int p)
	{
		return (p<<1);
	}
	static int right(int p)
	{
		return (p<<1)+1;
	}
	static int parent(int p)
	{
		return (p>>1);
	} 
	static void build_segment_tree(int p,int L,int R)
	{
		if(L==R)
			segment_tree[p]=a[L]; 
		else
		{
			build_segment_tree(left(p),L,(L+R)/2);
			build_segment_tree(right(p),((L+R)/2)+1,R);
			int x=segment_tree[left(p)];
			int y=segment_tree[right(p)];
			if(x<=y)
				segment_tree[p]=x;
			else
				segment_tree[p]=y;
		}
	}
	static int rmq(int i,int j)
	{
		return rmq_helper(1,0,len-1,i,j);
	}
	static int rmq_helper(int p,int L,int R,int i,int j)
	{
		if(L>R)
			return -1;
		if(j<L || i>R)
			return -1;
		if(i<=L && j>=R)
			return segment_tree[p];
		else
		{
			int mid=(L+R)/2; 
			int x=rmq_helper(left(p),L,mid,i,j);
			int y=rmq_helper(right(p),mid+1,R,i,j);
			if(x==-1)
				return y;
			if(y==-1)
				return x; 
			if(x<y)
				return x;
			else 
				return y;
		}
	}
}
------------------------------
import java.util.*;
import java.io.*;
public class C {

	public static void main(String[] args) {
		FastScanner sc = new FastScanner();
		int t = sc.nextInt();
		StringBuilder sb = new StringBuilder();
		while(t-->0) {
			int n = sc.nextInt();
			int[] arr = new int[n];
			ArrayList<Integer>[] poss = new ArrayList[n+1];
			for(int i = 1; i <= n; i++){
				poss[i] = new ArrayList<>();
			}
			for(int i = 0; i < n; i++){
				arr[i] = sc.nextInt();
				poss[arr[i]].add(i);
			}
			TreeSet<Pair> ps = new TreeSet<>();
			ps.add(new Pair(0, n-1));
			int[] life = new int[n+1];
			for(int i = 1; i <= n; i++){
				for(int p: poss[i]) {
					Pair pa = ps.floor(new Pair(p,p));
					if(pa == null) continue;
					life[i] = Math.max(life[i], pa.b - pa.a + 1);
					ps.remove(pa);
					ps.add(new Pair(pa.a, p-1));
					ps.add(new Pair(p+1, pa.b));
				}
			}
			boolean[] valid = new boolean[n+1];
			for(int i = 1; i <= n; i++){
				if(poss[i].isEmpty()) break;
				else valid[i] = true;
			}
			int[] d = new int[n+2];
			for(int i = 1; i <= n; i++){
				if(!poss[i].isEmpty()) {
					d[0]++; d[life[i]]--;
				}
			}
			int[] dacc = new int[n];
			for(int i = 0; i < n; i++){
				if(i == 0) dacc[i] = d[i];
				else dacc[i] = dacc[i-1] + d[i];
			}
			char[] ans = new char[n];
			for(int i = 0; i < n; i++){
				if(valid[n-i] && dacc[i] == n-i) ans[i] = '1';
				else ans[i] = '0';
			}
			sb.append(ans);
			sb.append("\n");
		}
		PrintWriter pw = new PrintWriter(System.out);
		pw.println(sb.toString().trim());
		pw.flush();
	}
	
	static class Pair implements Comparable<Pair>{
		int a, b;
		public Pair(int a, int b){
			this.a = a; this.b = b;
		}
		public int compareTo(Pair p){
			return a - p.a;
		}
		public String toString(){
			return a + " " + b;
		}
	}
	
	static class FastScanner {
		public BufferedReader reader;
		public StringTokenizer tokenizer;
		public FastScanner() {
			reader = new BufferedReader(new InputStreamReader(System.in), 32768);
			tokenizer = null;
		}
		public String next() {
			while (tokenizer == null || !tokenizer.hasMoreTokens()) {
				try {
					tokenizer = new StringTokenizer(reader.readLine());
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			return tokenizer.nextToken();
		}
		public int nextInt() {
			return Integer.parseInt(next());
		}
		public long nextLong() {
			return Long.parseLong(next());
		}
		public double nextDouble() {
			return Double.parseDouble(next());
		}
		public String nextLine() {
			try {
				return reader.readLine();
			} catch(IOException e) {
				throw new RuntimeException(e);
			}
		}
	}

}

------------------------------
import java.io.*;
import java.util.*;
import java.math.*;

public class D {
	static byte[] buf = new byte[1<<26];
    static int bp = -1;	
	
	public static void main(String[] args) throws IOException {

		/**/
		DataInputStream in = new DataInputStream(System.in);
		/*/
		DataInputStream in = new DataInputStream(new FileInputStream("src/d.in"));
		/**/
		
		in.read(buf, 0, 1<<26);
		int t = nni();
		for (int z = 0; z < t; ++z) {
			int n = nni();
			int[] a = new int[n];
			for (int i = 0; i < n; ++i)
				a[i] = nni();
			int[] cts = new int[n+1];
			for (int x : a)
				cts[x]++;
			boolean[] hap = new boolean[n+1];
			boolean[] unhap = new boolean[n+1];
			TreeSet<Integer> rem = new TreeSet<Integer>();
			int[] some = new int[n+1];
			for (int i = 0; i < n; ++i) {
				rem.add(i);
				some[a[i]] = i;
			}
			for (int i = 1; i <= n; ++i) {
				if (!unhap[i]&&cts[i]>=1)
					hap[i] = true;
				if (a[rem.first()]!=i&&a[rem.last()]!=i)
					break;
				if (cts[i]!=1)
					break;
				rem.remove(some[i]);
			}
			hap[n] = true;
			for (int i = 1; i <= n; ++i)
				if (cts[i]!=1)
					hap[n] = false;
			StringBuilder ans = new StringBuilder();
			for (int i = n; i>=1; --i)
				ans.append(hap[i]?'1':'0');
			System.out.println(ans);
		}
	}
		
	public static int nni() {
        int ret = 0;
        byte b = buf[++bp];
        while (true) {
            ret = ret*10+b-'0';
            b = buf[++bp];
            if (b<'0'||b>'9') {
            	while (buf[bp+1]=='\r'||buf[bp+1]=='\n'||buf[bp+1]==' ') {++bp;}
            	break;
            }
        }
        return ret;
    }
}
------------------------------
import java.io.*; 
import java.util.*; 
import java.math.*; 

public class Main {
	public static void main(String[] args) throws IOException 
	{ 
		FastScanner f = new FastScanner(); 
		int t=f.nextInt();
//		int t=1;
		PrintWriter out=new PrintWriter(System.out);
		while(t>0) {
			t--;
			int n=f.nextInt();
			int[] l=f.readArray(n);
			char[] ans=new char[n];
			HashSet<Integer> h=new HashSet<>();
			HashMap<Integer,Integer> map=new HashMap<>();
			Arrays.fill(ans,'0');
			for(int i=0;i<n;i++) {
				h.add(l[i]);
				if(map.containsKey(l[i])) {
					map.put(l[i],map.get(l[i])+1);
				}
				else {
					map.put(l[i],1);
				}
			}
			if(h.size()==n) {
				ans[0]='1';
			}
			int start=0;
			int end=n-1;
			int curr=1;
			while(end>start) {
				if(!map.containsKey(curr) || (map.containsKey(curr) && map.get(curr)!=1)) {
					break;
				}
				else {
					if(l[start]==curr) {
						start++;
						curr++;
					}
					else if(l[end]==curr) {
						end--;
						curr++;
					}
					else {
						break;
					}
				}
			}
			if(h.contains(curr) && (end-start+1)==(n-curr+1)) curr++;
//			System.out.println(curr);
			for(int i=n-1;i>Math.max(0,n-curr);i--) {
				ans[i]='1';
			}
			System.out.println(ans);
		}
		out.close();
	} 
	static void sort(int [] a) {
        ArrayList<Integer> q = new ArrayList<>();
        for (int i: a) q.add(i);
        Collections.sort(q);
        for (int i = 0; i < a.length; i++) a[i] = q.get(i);
    }
    
	static class FastScanner {
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st=new StringTokenizer("");
		String next() {
			while (!st.hasMoreTokens())
				try {
					st=new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			return st.nextToken();
		}
		
		int nextInt() {
			return Integer.parseInt(next());
		}
		int[] readArray(int n) {
			int[] a=new int[n];
			for (int i=0; i<n; i++) a[i]=nextInt();
			return a;
		}
		long nextLong() {
			return Long.parseLong(next());
		}
		double nextDouble() {
			return Double.parseDouble(next());
		}
		long[] readLongArray(int n) {
			long[] a=new long[n];
			for (int i=0; i<n; i++) a[i]=nextLong();
			return a;
		}
	}
} 
------------------------------


Write a python script that can generate test cases for a programming problem with the provided problem statement and solution codes. The test case should be focus on exhausting the code to get time limit exceeded and should follow the input format. The python script should be able to read an argument which specify a directory and write all the testcases as 'test_01.in', 'test_02.in', ... into the directory.