Problem Statement
The tycoon of a winery empire in Mondstadt, unmatched in every possible way. A thinker in the Knights of Favonius with an exotic appearance.

This time, the brothers are dealing with a strange piece of wood marked with their names. This plank of wood can be represented as a string of n characters. Each character is either a 'D' or a 'K'. You want to make some number of cuts (possibly 0) on this string, partitioning it into several contiguous pieces, each with length at least 1. Both brothers act with dignity, so they want to split the wood as evenly as possible. They want to know the maximum number of pieces you can split the wood into such that the ratios of the number of occurrences of 'D' to the number of occurrences of 'K' in each chunk are the same.

Kaeya, the curious thinker, is interested in the solution for multiple scenarios. He wants to know the answer for every prefix of the given string. Help him to solve this problem!

For a string we define a ratio as a:b where 'D' appears in it a times, and 'K' appears b times. Note that a or b can equal 0, but not both. Ratios a:b and c:d are considered equal if and only if a⋅ d = b⋅ c. 

For example, for the string 'DDD' the ratio will be 3:0, for 'DKD' — 2:1, for 'DKK' — 1:2, and for 'KKKKDD' — 2:4. Note that the ratios of the latter two strings are equal to each other, but they are not equal to the ratios of the first two strings.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first line of each test case contains an integer n (1 ≤ n ≤ 5 ⋅ 10^5) — the length of the wood.

The second line of each test case contains a string s of length n. Every character of s will be either 'D' or 'K'.

It is guaranteed that the sum of n over all test cases does not exceed 5 ⋅ 10^5.

Output

For each test case, output n space separated integers. The i-th of these numbers should equal the answer for the prefix s_{1},s_{2},...,s_{i}.

Example

Input


5
3
DDK
6
DDDDDD
4
DKDK
1
D
9
DKDKDDDDK


Output


1 2 1 
1 2 3 4 5 6 
1 1 1 2 
1 
1 1 1 2 1 2 1 1 3 

Note

For the first test case, there is no way to partition 'D' or 'DDK' into more than one block with equal ratios of numbers of 'D' and 'K', while you can split 'DD' into 'D' and 'D'.

For the second test case, you can split each prefix of length i into i blocks 'D'.
------------------------------
import java.util.*;
import java.io.*;
import java.lang.Math;


public class DK{
	public static int gcd(int a, int b)
	{
		if (a<b){
			int temp =a;
			a = b;
			b=temp;
		}
		if (b==0) {
			return a;
		}
		else{
			return gcd(b,a%b);
		}
	}
	 
	public static void main(String[] args) {
		Scanner console = new Scanner(System.in);
 
		int t = console.nextInt();

		for (int o=0;o< t ;o++ ) {
			int n=console.nextInt();

			int[] vals = new int[n];
			String s = console.next();

			Ratio[] subs = new Ratio[n];
			int k=0;
			int d=0;

			for (int i=0;i<n ;i++ ) {
				char ch = s.charAt(i);
		        int a = ch - 'D';				
		        if(a ==0){
		        	vals[i]=0;
		        }
		        if(a>0){
		        	vals[i]=1;
		        }
		        if(a<0){
		        	System.out.println("DEBUGGG");
		        }

				if(vals[i]==0){
					d++;
				}
				else{
					k++;
				}
				int ooo=0;

				int dif = (k+d)/gcd(k,d);
				for (int j=i-dif;j>=0 ;j-=dif ) {
					if(subs[j].k*d == subs[j].d*k){
						ooo = subs[j].occ+1;
						break;
					}
				}
				System.out.print((ooo+1)+" ");
				Ratio pepe = new Ratio(k,d,ooo);
				subs[i]=pepe;		        
			}

			System.out.println();

		}
	}
}

class Ratio {
	public int k;
	public int d;
	public int occ;

	public Ratio(int k, int d, int occ) {
		this.k=k;
		this.d=d;
		this.occ = occ;
	}
}

------------------------------
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.Map.Entry;

import java.util.Random;
import java.util.TreeSet;

public final class CF_724_D2_C
{


	static boolean verb=true;
	static void log(Object X){if (verb) System.err.println(X);}
	static void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+" ");System.err.println("");}}
	static void log(int[] X){if (verb) {for (int U:X) System.err.print(U+" ");System.err.println("");}}
	static void logWln(int[] X){if (verb) {for (int U:X) System.err.print(U+" ");}}
	static void log(int[] X,int L){if (verb) {for (int i=0;i<L;i++) System.err.print(X[i]+" ");System.err.println("");}}
	static void log(long[] X){if (verb) {for (long U:X) System.err.print(U+" ");System.err.println("");}}

	static void logWln(Object X){if (verb) System.err.print(X);}
	static void info(Object o){	System.out.println(o);}
	static void output(Object o){outputWln(""+o+"\n");	}
	static void outputFlush(Object o){try {out.write(""+ o+"\n");out.flush();} catch (Exception e) {}}
	static void outputWln(Object o){try {out.write(""+ o);} catch (Exception e) {}}


	static void logBin(int[] tm) {for (int x:tm) logWln(bin(8,x)+" ");log("");}

	static String bin(int L,int x) {
		String s=Integer.toBinaryString(x);
		while (s.length()<L) s="0"+s;
		return s;
	}

	static long powerMod(long b,long e,long m){
		long x=1;
		while (e>0) {
			if (e%2==1)			
				x=(b*x)%m;
			b=(b*b)%m;
			e=e/2;
		}
		return x; 
	}



	static long mod=1000000007;



	// Global vars
	static BufferedWriter out;
	static InputReader reader;

	static int pgcd(int a,int b){
		if (a<b)
			return pgcd(b,a);
		while (b!=0){
			int c=b;
			b=a%b;
			a=c;
		}
		return a;
	}



	static void process() throws Exception {


		out = new BufferedWriter(new OutputStreamWriter(System.out));
		reader = new InputReader(System.in);

		int T=reader.readInt();
		int CX=26;
		for (int t=0;t<T;t++) {
			int n=reader.readInt();
			String s=reader.readString();
			int[] cnt=new int[n];
			int D=0;
			int K=0;
			HashMap<String,ArrayList<Integer>> hm=new HashMap<String,ArrayList<Integer>>();
			for (int i=0;i<n;i++) {
				if (i>0)
					cnt[i]=cnt[i-1];
				if (s.charAt(i)=='D') {
					cnt[i]++;
					D++;
				} else {
					K++;
				}
				int p=pgcd(D,K);
				int d=D/p;
				int k=K/p;
				String ss=d+":"+k;
				ArrayList<Integer> lst=hm.get(ss);
				if (lst==null) {
					lst=new ArrayList<Integer>();
					hm.put(ss,lst);
				}
				lst.add(i);
				outputWln(lst.size()+" ");
				
			}
			output("");
		
		}


		try {
			out.close();
		} catch (Exception Ex) {
		}

	}


	public static void main(String[] args) throws Exception {
		process();

	}

	static final class InputReader {
		private final InputStream stream;
		private final byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public InputReader(InputStream stream) {
			this.stream = stream;
		}

		private int read() throws IOException {
			if (curChar >= numChars) {
				curChar = 0;
				numChars = stream.read(buf);
				if (numChars <= 0) {
					return -1;
				}
			}
			return buf[curChar++];
		}

		public final String readString() throws IOException {
			int c = read();
			while (isSpaceChar(c)) {
				c = read();
			}
			StringBuilder res = new StringBuilder();
			do {
				res.append((char) c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public final String readString(int L) throws IOException {
			int c = read();
			while (isSpaceChar(c)) {
				c = read();
			}
			StringBuilder res = new StringBuilder(L);
			do {
				res.append((char) c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public final int readInt() throws IOException {
			int c = read();
			boolean neg = false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d = (char) c;
			// log("d:"+d);
			if (d == '-') {
				neg = true;
				c = read();
			}
			int res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			// log("res:"+res);
			if (neg)
				return -res;
			return res;

		}

		public final long readLong() throws IOException {
			int c = read();
			boolean neg = false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d = (char) c;
			// log("d:"+d);
			if (d == '-') {
				neg = true;
				c = read();
			}
			long res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			// log("res:"+res);
			if (neg)
				return -res;
			return res;

		}

		private boolean isSpaceChar(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}
	}

}
------------------------------
import java.util.*;
import java.io.*;


public class Main{
    public static int gcd(int a, int b)
    {
        if (a == 0)
            return b;

        return gcd(b%a, a);
    }
    public static void main(String[] args) throws java.io.IOException {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        int t=Integer.parseInt(br.readLine());
        while(t-->0)
        {
            int n=Integer.parseInt(br.readLine());
            String str=br.readLine();
            HashMap<ArrayList<Integer>,Integer> map=new HashMap<>();
            int[] dp=new int[n];
            int d_count=0;
            int k_count=0;
            StringBuilder sb=new StringBuilder();
            for(int i=0;i<n;++i)
            {
                if(str.charAt(i)=='D')
                    d_count++;
                else
                    k_count++;
                int gcd=gcd(k_count,d_count);
                int cur_d=d_count/gcd;
                int cur_k=k_count/gcd;
                ArrayList<Integer> list=new ArrayList<>();
                list.add(cur_d);
                list.add(cur_k);
                int old=map.getOrDefault(list,0)+1;
                map.put(list,old);
                dp[i]=old;
                sb.append(dp[i]+" ");
            }
            System.out.println(sb.toString());
        }
    }
}
// 1 0 1 1 0 0 1
------------------------------
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;

public class DilucAndKaeya {
    public static void main(String[] args) throws IOException {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
            int testCases = Integer.parseInt(reader.readLine());

            for (int i = 0; i < testCases; i++) {
                reader.readLine();
                System.out.println(solveTask(reader.readLine()));
            }
        }
    }

    private static String solveTask(String s) {
        HashMap<String, Integer> map = new HashMap<>();
        StringBuilder sb = new StringBuilder();
        int numberOfD = 0;
        int numberOfK = 0;
        for (int i = 0; i < s.length(); i++) {

            if (s.charAt(i) == 'D') {
                numberOfD++;
            } else {
                numberOfK++;
            }

            String ratio = getRatio(numberOfD, numberOfK);
            if (map.containsKey(ratio)) {
                map.put(ratio, map.get(ratio) + 1);
            } else {
                map.put(ratio, 1);
            }
            sb.append(map.get(ratio)).append(" ");
        }
        return sb.toString();
    }

    private static String getRatio(final int numberOfD, final int numberOfK) {
        int a = numberOfD, b = numberOfK;
        if (a == 0) {
            b = 1;
        } else if (b == 0) {
            a = 1;
        } else {
            int greatestCommonDivisor = getGreatestCommonDivisor(a, b);
            a /= greatestCommonDivisor;
            b /= greatestCommonDivisor;
        }

        return a + ":" + b;
    }

    private static int getGreatestCommonDivisor(int a, int b) {
        if (a > b) {
            int temp = a;
            a = b;
            b = temp;
        }
        return a == 0 ? b : getGreatestCommonDivisor(b % a, a);
    }
}

------------------------------
import javax.xml.crypto.dsig.spec.XSLTTransformParameterSpec;
import java.awt.*;
import java.beans.IntrospectionException;
import java.io.*;
import java.util.*;
import java.lang.*;

public class Main{
    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
    static long MOD = (long) (1e9 + 7);
    //    static long MOD = 998244353;
    static long MOD2 = MOD * MOD;
    static FastReader sc = new FastReader();
    static int pInf = Integer.MAX_VALUE;
    static int nInf = Integer.MIN_VALUE;
    static long ded = (long)(1e17)+9;
    public static void main(String[] args) throws Exception {
        int test = 1;
        test = sc.nextInt();
        for (int i = 1; i <= test; i++){
//            out.print("Case #"+i+": ");
            solve();
        }
        out.flush();
        out.close();
    }
    static void solve(){
        int n = sc.nextInt();
        String s = sc.next();
        char[] c = s.toCharArray();
        int[] k = new int[n+1];
        int[] d = new int[n+1];
        int[] ans = new int[n];
        TreeMap<Node,Integer> A = new TreeMap<Node, Integer>();
        for(int i = 0; i < n; i++){
            if(c[i]=='D'){
                d[i+1] = d[i]+1;
                k[i+1] = k[i];
            }else{
                k[i+1] = k[i]+1;
                d[i+1] = d[i];
            }
            int len = i+1;
            int cntd = d[i+1];
            int cntk = k[i+1];
            int gcd = (int)gcd(cntd,cntk);
            Node node = new Node(len/gcd,cntd/gcd,cntk/gcd);
            A.put(node,A.getOrDefault(node,0)+1);
            ans[i] = A.get(node);
        }
        for(int x: ans){
            out.print(x+" ");
        }
        out.println();
    }
    static class Node implements Comparable<Node>{
        int len;
        int x;
        int y;
        public Node(int len,int x,int y){
            this.len = len;
            this.x = x;
            this.y = y;
        }
        @Override
        public int compareTo(Node o){
            if(this.x==o.x){
                return -1*(o.y-this.y);
            }
            return this.x-o.x;
        }
        public boolean equals(Node o){
            return this.len==o.len&&this.x==o.x&&this.y==o.y;
        }
    }
    static class Pair implements Comparable<Pair> {
        int x;
        int y;
        public Pair(int x, int y) {
            this.x = x;
            this.y = y;
        }
        @Override
        public int compareTo(Pair o){
            if(this.x==o.x){
                return -1*(o.y-this.y);
            }
            return this.x-o.x;
        }

        @Override
        public String toString() {
            return "Pair{" + "x=" + x + ", y=" + y + '}';
        }

        public boolean equals(Pair o){
            return this.x==o.x&&this.y==o.y;
        }
    }
    public static long mul(long a, long b) {
        return ((a % MOD) * (b % MOD)) % MOD;
    }
    public static long add(long a, long b) {
        return ((a % MOD) + (b % MOD)) % MOD;
    }
    public static long c2(long n) {
        if ((n & 1) == 0) {
            return mul(n / 2, n - 1);
        } else {
            return mul(n, (n - 1) / 2);
        }
    }
    //Shuffle Sort
    static final Random random = new Random();
    static void ruffleSort(int[] a) {
        int n = a.length;//shuffle, then sort
        for (int i = 0; i < n; i++) {
            int oi = random.nextInt(n); int temp= a[oi];
            a[oi] = a[i];
            a[i] = temp;
        }
        Arrays.sort(a);
    }
    //Brian Kernighans Algorithm
    static long countSetBits(long n) {
        if (n == 0) return 0;
        return 1 + countSetBits(n & (n - 1));
    }
    //Euclidean Algorithm
    static long gcd(long A, long B) {
        if (B == 0) return A;
        return gcd(B, A % B);
    }
    //Modular Exponentiation
    static long fastExpo(long x, long n) {
        if (n == 0) return 1;
        if ((n & 1) == 0) return fastExpo((x * x) % MOD, n / 2) % MOD;
        return ((x % MOD) * fastExpo((x * x) % MOD, (n - 1) / 2)) % MOD;
    }
    //AKS Algorithm
    static boolean isPrime(long n) {
        if (n <= 1) return false;
        if (n <= 3) return true;
        if (n % 2 == 0 || n % 3 == 0) return false;
        for (int i = 5; i <= Math.sqrt(n); i += 6)
            if (n % i == 0 || n % (i + 2) == 0) return false;
        return true;
    }
    public static long modinv(long x) {
        return modpow(x, MOD - 2);
    }
    public static long modpow(long a, long b) {
        if (b == 0) {
            return 1;
        }
        long x = modpow(a, b / 2);
        x = (x * x) % MOD;
        if (b % 2 == 1) {
            return (x * a) % MOD;
        }
        return x;
    }


    static class FastReader {
        BufferedReader br;
        StringTokenizer st;
        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = "";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}
------------------------------


Write a python script that can generate test cases for a programming problem with the provided problem statement and solution codes. The test case should be focus on exhausting the code to get time limit exceeded and should follow the input format. The python script should be able to read an argument which specify a directory and write all the testcases as 'test_01.in', 'test_02.in', ... into the directory.