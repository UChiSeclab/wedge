Problem Statement
The tycoon of a winery empire in Mondstadt, unmatched in every possible way. A thinker in the Knights of Favonius with an exotic appearance.

This time, the brothers are dealing with a strange piece of wood marked with their names. This plank of wood can be represented as a string of n characters. Each character is either a 'D' or a 'K'. You want to make some number of cuts (possibly 0) on this string, partitioning it into several contiguous pieces, each with length at least 1. Both brothers act with dignity, so they want to split the wood as evenly as possible. They want to know the maximum number of pieces you can split the wood into such that the ratios of the number of occurrences of 'D' to the number of occurrences of 'K' in each chunk are the same.

Kaeya, the curious thinker, is interested in the solution for multiple scenarios. He wants to know the answer for every prefix of the given string. Help him to solve this problem!

For a string we define a ratio as a:b where 'D' appears in it a times, and 'K' appears b times. Note that a or b can equal 0, but not both. Ratios a:b and c:d are considered equal if and only if a⋅ d = b⋅ c. 

For example, for the string 'DDD' the ratio will be 3:0, for 'DKD' — 2:1, for 'DKK' — 1:2, and for 'KKKKDD' — 2:4. Note that the ratios of the latter two strings are equal to each other, but they are not equal to the ratios of the first two strings.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first line of each test case contains an integer n (1 ≤ n ≤ 5 ⋅ 10^5) — the length of the wood.

The second line of each test case contains a string s of length n. Every character of s will be either 'D' or 'K'.

It is guaranteed that the sum of n over all test cases does not exceed 5 ⋅ 10^5.

Output

For each test case, output n space separated integers. The i-th of these numbers should equal the answer for the prefix s_{1},s_{2},...,s_{i}.

Example

Input


5
3
DDK
6
DDDDDD
4
DKDK
1
D
9
DKDKDDDDK


Output


1 2 1 
1 2 3 4 5 6 
1 1 1 2 
1 
1 1 1 2 1 2 1 1 3 

Note

For the first test case, there is no way to partition 'D' or 'DDK' into more than one block with equal ratios of numbers of 'D' and 'K', while you can split 'DD' into 'D' and 'D'.

For the second test case, you can split each prefix of length i into i blocks 'D'.
------------------------------
import java.io.*;
import java.util.*;

public class Main
{
    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
    static StreamTokenizer st=new StreamTokenizer(br);

    static int nextInt() throws IOException
    {
        st.nextToken();
        return (int)st.nval;
    }

    static String nextStr() throws IOException
    {
        st.nextToken();
        return st.sval;
    }

    static int brReadInt() throws IOException
    {
        return Integer.parseInt(br.readLine());
    }

    static long brReadLong() throws IOException
    {
        return Long.parseLong(br.readLine());
    }

    static int gcd(int a, int b)
    {
        return b==0 ? a : gcd(b, a%b);
    }

    public static void main(String[] args) throws IOException
    {
        int T=nextInt();
        while(T-->0)
        {
            int n=nextInt();
            String s=nextStr();
            char[] chs=s.toCharArray();
            StringBuilder ans=new StringBuilder();

            Map<int[], Integer> map=new TreeMap<>((o1, o2)->o1[0]==o2[0] ? o1[1]-o2[1] : o1[0]-o2[0]);
            int dCnt=0, kCnt=0;
            for(int i=0; i<n; i++)
            {
                if(chs[i]=='D')
                    dCnt++;
                else
                    kCnt++;

                if(dCnt==0 || kCnt==0)
                {
                    System.out.print((i+1)+" ");
                    continue;
                }

                int g=gcd(dCnt, kCnt);
                int[] key={dCnt/g, kCnt/g};
                int res=map.getOrDefault(key, 0)+1;
                map.put(key, res);
                ans.append(res).append(" ");
            }
            System.out.println(ans);
        }
    }
}

class HideArray
{
    int[] preSum;

    HideArray(int[] nums)
    {
        int n=nums.length;
        preSum=new int[n+1];
        for(int i=1; i<=n; i++)
            preSum[i]=preSum[i-1]+nums[i-1];
    }

    int getPreSum(int right)
    {
        return preSum[right];
    }
}
------------------------------
import java.io.*;
import java.util.*;

public class Main {

    static Scanner sc;
    static PrintWriter out;

    public static void main(String[] args) {
        sc = new Scanner(System.in);
        out = new PrintWriter(System.out);
        int t = 1;
        if (true) {
            t = sc.nextInt();
        }
        for(int i=0; i<t; i++) {
            new Main().solve();
        }
        out.flush();
    }

    public void solve() {
        int n = sc.nextInt();
        char[] c = sc.next().toCharArray();
        int[] a = new int[n];
        int d = 0;
        int k = 0;
        Map<String ,Integer> map = new HashMap<>();
        for(int i=0; i<n; i++) {
            if(c[i]=='D') {
                d++;
            } else {
                k++;
            }
            String key = ratio(d, k);
            a[i] = map.getOrDefault(key, 0) + 1;
            map.put(key, a[i]);
        }

        for(int i=0; i<n; i++) {
            if(i>0) out.print(" ");
            out.print(a[i]);
        }
        out.println();
    }

    String ratio (int d, int k) {
        if(d == 0) {
            return "1:0";
        } else if (k == 0) {
            return "0:1";
        } else {
            int gcd = gcd(d , k);
            int dd = d/gcd;
            int kk = k/gcd;
            return dd + ":" + kk;
        }
    }

    static int gcd(int m, int n) {
        if(m < n) return gcd(n, m);
        if(n == 0) return m;
        return gcd(n, m % n);
    }


}

------------------------------
import java.io.*;
import java.util.*;

public class tank {

    static final FastScanner fs = new FastScanner();

    static PrintWriter out = new PrintWriter(System.out);

    public static void main(String[] args) {
        int t = fs.nextInt();
        while(t-->0) {
            run_case();
        }

        out.close();
    }

    static void run_case() {
        int n = fs.nextInt(), d = 0, k = 0;
        char[] arr = fs.next().toCharArray();
        int[] ans = new int[n];

        HashMap<String, Integer> hm = new HashMap<>();

        for (int i = 0; i < n; i++) {
            if(arr[i] == 'D') d++;
            else k++;

            if(d == 0) {
                hm.put("0/1", hm.getOrDefault("0/1", 0) + 1);
                ans[i] = hm.get("0/1");
            }else if(k == 0) {
                hm.put("1/0", hm.getOrDefault("1/0", 0) + 1);
                ans[i] = hm.get("1/0");
            }else {
                int gc = gcd(d, k), dd = d/gc, kk = k/gc;
                String ke = dd + "/" + kk;
                hm.put(ke, hm.getOrDefault(ke, 0) + 1);
                ans[i] = hm.get(ke);
            }
        }

        for(int i: ans) out.print(i + " ");
        out.println();
    }

    static int gcd(int a, int b) {
        if (a == 0)
            return b;
        return gcd(b % a, a);
    }

    static class FastScanner {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st=new StringTokenizer("");
        String next() {
            while (!st.hasMoreTokens())
                try {
                    st=new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            return st.nextToken();
        }

        String nextLine(){
            try {
                return br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }

            return "";
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        int[] readArray(int n) {
            int[] a=new int[n];
            for (int i=0; i<n; i++) a[i]=nextInt();
            return a;
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }
    }
}
------------------------------
import java.io.*;
import java.util.*;

public class A {

    static boolean LOCAL = false;

    static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a%b);
    }

    public static void main(String[] args) throws  java.lang.Exception {
        BufferedReader in = new BufferedReader(new InputStreamReader(LOCAL ? (new FileInputStream("/home/xiongjx751/Workspace/AlgJava/src/in.txt")) : System.in));
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(LOCAL ? (new FileOutputStream("/home/xiongjx751/Workspace/AlgJava/src/out.txt")) : System.out));

        int T = Integer.parseInt(in.readLine());
        while (T-- > 0) {
            int n = Integer.parseInt(in.readLine());
            char[] s = in.readLine().toCharArray();
            int D = 0, K = 0;
            HashMap<String, Integer> mp = new HashMap<>();
            for (int i = 0; i < n; i++) {
                D += (s[i] == 'D') ? 1 : 0;
                K += (s[i] == 'K') ? 1 : 0;
                int g = gcd(D, K);
                String str = new String((D/g) + ":" + (K/g));
                int a = mp.containsKey(str) ? mp.get(str) + 1 : 1;
                out.write(a + " ");
                mp.put(str, a);
            }
            out.write("\n");
            out.flush();
        }

    }

}


------------------------------
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;
import java.util.StringTokenizer;

public class Main {

    static class FastReader {
            BufferedReader br;
            StringTokenizer st;

            public FastReader()
            {
                br = new BufferedReader(
                        new InputStreamReader(System.in));
            }

            String next()
            {
                while (st == null || !st.hasMoreElements()) {
                    try {
                        st = new StringTokenizer(br.readLine());
                    }
                    catch (IOException e) {
                        e.printStackTrace();
                    }
                }
                return st.nextToken();
            }

            int nextInt() { return Integer.parseInt(next()); }

            long nextLong() { return Long.parseLong(next()); }

            double nextDouble()
            {
                return Double.parseDouble(next());
            }

            String nextLine()
            {
                String str = "";
                try {
                    str = br.readLine();
                }
                catch (IOException e) {
                    e.printStackTrace();
                }
                return str;
            }
        }

    public static void main(String[] args) {
        FastReader in = new FastReader();

        int test = in.nextInt();
        while (test-- > 0) solve(in);
    }

    private static void solve(FastReader in) {
        int n = in.nextInt();
        String s = in.next();

        Map<String, Integer> mp = new HashMap<>();
        StringBuilder ans = new StringBuilder();

        int d = 0, k = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == 'D') ++d;
            else ++k;
            int a = d, b = k;
            if (a == 0) b = 1;
            else if (b == 0) a = 1;
            else {
                int gcd = gcd(a, b);
                a /= gcd;
                b /= gcd;
            }
            String key = a + ":" + b;
            if (!mp.containsKey(key)) mp.put(key, 1);
            else mp.put(key, mp.get(key) + 1);
            ans.append(mp.get(key)).append(" ");
        }
        System.out.println(ans);

    }

    private static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a  % b);
    }

}
------------------------------


Write a python script that can generate test cases for a programming problem with the provided problem statement and solution codes. The test case should be focus on exhausting the code to get time limit exceeded and should follow the input format. The python script should be able to read an argument which specify a directory and write all the testcases as 'test_01.in', 'test_02.in', ... into the directory.