Problem Statement
One day in the IT lesson Anna and Maria learned about the lexicographic order.

String x is lexicographically less than string y, if either x is a prefix of y (and x ≠ y), or there exists such i (1 ≤ i ≤ min(|x|, |y|)), that xi < yi, and for any j (1 ≤ j < i) xj = yj. Here |a| denotes the length of the string a. The lexicographic comparison of strings is implemented by operator < in modern programming languages​​.

The teacher gave Anna and Maria homework. She gave them a string of length n. They should write out all substrings of the given string, including the whole initial string, and the equal substrings (for example, one should write out the following substrings from the string "aab": "a", "a", "aa", "ab", "aab", "b"). The resulting strings should be sorted in the lexicographical order. The cunning teacher doesn't want to check all these strings. That's why she said to find only the k-th string from the list. Help Anna and Maria do the homework.

Input

The first line contains a non-empty string that only consists of small Latin letters ("a"-"z"), whose length does not exceed 105. The second line contains the only integer k (1 ≤ k ≤ 105).

Output

Print the string Anna and Maria need — the k-th (in the lexicographical order) substring of the given string. If the total number of substrings is less than k, print a string saying "No such line." (without the quotes).

Examples

Input

aa
2


Output

a


Input

abc
5


Output

bc


Input

abab
7


Output

b

Note

In the second sample before string "bc" follow strings "a", "ab", "abc", "b".
------------------------------
import java.io.*;
import java.lang.Math;
import java.util.*;

public class Main
{
	public static Scanner in;
	public static PrintStream out;
	
	public static void test()
	{
		String s = in.nextLine();
		long k = in.nextLong();
		int n = s.length();
		
		int cnt[] = new int[27];
		long substr_cnt[] = new long[27];
		int pos[][] = new int[27][];
		
		
		int[] c_pos = new int[n+1];
		int c_count = 0;
		
		int i,j;
		for (i=0; i<27; i++)
		{
			cnt[i] = 0;
			pos[i] = new int[n+1];
		}
		
		int c, h;
		for (i=0; i<n; i++)
		{
			c = s.charAt(i)-'a';
			pos[c][cnt[c]++] = i;
		}
		
		int p = 0;
		long sm;
		
		String pref = "";
		
		while (true)
		{
			sm = 0;
			for (i=0; i<26; i++)
			{
				substr_cnt[i] = 0;
				for (j=0; j<cnt[i]; j++)
				{
					substr_cnt[i] += (long)(n - pos[i][j] - p);
				}
				
				sm+= substr_cnt[i];
				
				if (sm > k)
				{
					break;
				}
			}
			
			i = 0;
			while ((i<26)&&(substr_cnt[i]<k))
			{
				k -= substr_cnt[i];
				i++;
			}
			
			if (i==26)
			{
				out.println("No such line.");
				return;
			}
			
			//pref =  pref + (char)(i+'a');
			p++;
			
			k-= cnt[i];
			
			if (k<=0)
			{
				out.println(s.substring(pos[i][0], pos[i][0]+p));
				return;
			}
			
			c = i;
			
			c_count = cnt[i];
			for (i=0;i<c_count;i++)
			{
				c_pos[i] = pos[c][i];
			}
			
			for (i=0; i<26;i++)
			{
				cnt[i] = 0;
			}
			
			for (j=0; j<c_count;j++)
			{
				if (c_pos[j]+p < n)
				{
					h = s.charAt(c_pos[j]+p) - 'a';
					pos[h][cnt[h]++] = c_pos[j];
				}
			}
		}
	}
       
	public static void main(String args[])
	{
		try
		{
			in = new Scanner(System.in);
			out = System.out;
			
			/*in = new Scanner(new File("in.txt"));
			out = new PrintStream(new File("out.txt"));*/
			
		}
		catch (Exception e)
		{
			return;
		}
	   
		/*int t = in.nextInt();
		for (int i=0; i<t; i++)*/
		{
			test();
		}
	}
}


------------------------------
import java.io.*;
import java.util.*;

public class CF129D {
	static StringBuilder sb = new StringBuilder();
	static char[] cc;
	static int[] aa;
	static int[] kk = new int[26];
	static long[] ll = new long[26];
	static void search(int n, int k) {
		for (int c = 0; c < 26; c++)
			ll[c] = kk[c] = 0;
		for (int i = 0; i < n; i++) {
			int j = aa[i];
			int c = cc[j] - 'a';
			kk[c]++;
			ll[c] += cc.length - j;
		}
		for (int c = 0; c < 26; c++) {
			if (k <= ll[c]) {
				int m = 0;
				for (int i = 0; i < n; i++) {
					int j = aa[i];
					if (cc[j] - 'a' == c && j + 1 < cc.length)
						aa[m++] = j + 1;
				}
				sb.append((char) ('a' + c));
				if (k > kk[c])
					search(m, k - kk[c]);	// m <= kk[c]
				return;
			}
			k -= ll[c];
		}
	}
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		cc = br.readLine().toCharArray();
		int n = cc.length;
		int k = Integer.parseInt(br.readLine());
		if (k > (long) n * (n + 1) / 2) {
			System.out.println("No such line.");
			return;
		}
		aa = new int[n];
		for (int i = 0; i < n; i++)
			aa[i] = i;
		search(n, k);	// O(n + k) amortized
		System.out.println(sb);
	}
}

------------------------------
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class Main {

	char[] str;
	int[] index;
	int[] count = new int[26];
	long[] sum = new long[26];
	StringBuffer sb = new StringBuffer();

	void search(int n, int k) {
		for (int c = 0; c < 26; c++)
			sum[c] = count[c] = 0;
		for (int i = 0; i < n; i++) {
			int j = index[i];
			int c = str[j] - 'a';
			count[c]++;
			sum[c] += str.length - j;
		}
//		Helper.tr(n, k, index, count, sum);
		for (int c = 0; c < 26; c++) {
			if (k <= sum[c]) {
				int m = 0;
				for (int i = 0; i < n; i++) {
					int j = index[i];
					if (str[j] - 'a' == c && j + 1 < str.length)
						index[m++] = j + 1;
				}
				sb.append((char) ('a' + c));
				if (k > count[c])
					search(m, k - count[c]);
				return;
			}
			k -= sum[c];
		}
	}

	private void solve() throws IOException {
		str = ns().toCharArray();
		int n = str.length;
		index = new int[n];
		for (int i=0; i<n;i++)
			index[i]= i;
		int k = ni();
		if (k > (long) n * (n + 1) / 2) {
			System.out.println("No such line.");
			return;
		}
		search(n, k);
		out.println(sb.toString());
		out.close();
	}

	static BufferedReader in;
	static PrintWriter out;
	static StringTokenizer tok;

	private int[][] na(int n) throws IOException {
		int[][] a = new int[n][2];
		for (int i = 0; i < n; i++) {
			a[i][0] = ni();
			a[i][1] = i;
		}
		return a;
	}

	String ns() throws IOException {
		while (!tok.hasMoreTokens()) {
			tok = new StringTokenizer(in.readLine(), " ");
		}
		return tok.nextToken();
	}

	int ni() throws IOException {
		return Integer.parseInt(ns());
	}

	long nl() throws IOException {
		return Long.parseLong(ns());
	}

	double nd() throws IOException {
		return Double.parseDouble(ns());
	}

	String[] nsa(int n) throws IOException {
		String[] res = new String[n];
		for (int i = 0; i < n; i++) {
			res[i] = ns();
		}
		return res;
	}

	int[] nia(int n) throws IOException {
		int[] res = new int[n];
		for (int i = 0; i < n; i++) {
			res[i] = ni();
		}
		return res;
	}

	long[] nla(int n) throws IOException {
		long[] res = new long[n];
		for (int i = 0; i < n; i++) {
			res[i] = nl();
		}
		return res;
	}

	public static void main(String[] args) throws IOException {
		in = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);
		tok = new StringTokenizer("");
		Main main = new Main();
		main.solve();
		out.close();
	}
}
------------------------------
import java.util.Arrays;
import java.util.ArrayList;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.IOException;
import java.util.StringTokenizer;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Artem Gilmudinov
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		Reader in = new Reader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskD solver = new TaskD();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskD {
    public void solve(int testNumber, Reader in, PrintWriter out) {
        String s = in.rl();
        int k = in.ni();
        int n = s.length();
        long cur = 0;
        ArrayList<Integer> pos = new ArrayList<>();
        long[] to = new long[27];
        for(int i = 0; i < n; i++) {
            to[s.charAt(i) - 'a'] += n - i;
        }
        if(k > ((long)n * (n + 1)) / 2) {
            out.println("No such line.");
            return;
        }
        long temp = 0;
        for(int i = 0; i < 26; i++) {
            if(temp < k && temp + to[i] >= k) {
                for(int j = 0; j < n; j++) {
                    if(s.charAt(j) - 'a' == i) {
                        pos.add(j);
                    }
                }
                cur = temp;
                out.print((char)('a' + i));
                break;
            }
            temp += to[i];
        }
        while(true) {
            Arrays.fill(to, 0);
            for(int i = 0; i < pos.size(); i++) {
                if(pos.get(i) < n - 1) {
                    to[s.charAt(pos.get(i) + 1) - 'a' + 1] += n - pos.get(i) - 1;
                }
            }
            to[0] = pos.size();
            temp = cur;
            int res = 0;
            for(int i = 0; i < 27; i++) {
                if(temp < k && temp + to[i] >= k) {
                    res = i;
                    break;
                }
                temp += to[i];
            }
            if(res == 0) {
                break;
            }
            ArrayList<Integer> list = new ArrayList<>();
            for(int i = 0; i < pos.size(); i++) {
                if(pos.get(i) < n - 1) {
                    if(s.charAt(pos.get(i) + 1) - 'a' + 1 == res) {
                        list.add(pos.get(i) + 1);
                    }
                }
            }
            out.print((char)('a' + res - 1));
            cur = temp;
            pos = list;
        }
    }
}

class Reader {
    private BufferedReader in;
    private StringTokenizer st = new StringTokenizer("");
    private String delim = " ";

    public Reader(InputStream in) {
        this.in = new BufferedReader(new InputStreamReader(in));
    }

    public String next() {
        if (!st.hasMoreTokens()) {
            st = new StringTokenizer(rl());
        }
        return st.nextToken(delim);
    }

    public String rl() {
        try {
            return in.readLine();
        } catch(IOException e) {
            throw new RuntimeException(e);
        }
    }

    public int ni() {
        return Integer.parseInt(next());
    }

}


------------------------------
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Vector;

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out);

        String s = in.readLine();
        int k = Integer.parseInt(in.readLine());

        Vector<Integer> positions = new Vector<Integer>();
        for (int i = 0; i < s.length(); i++)
            positions.add(i - 1);

        int enough_last = 0;
        StringBuilder ans = new StringBuilder();
        boolean noline = false;
        Vector<Vector<Integer>> pos = new Vector<Vector<Integer>>();
        for (int i = 0; i < 26; i++)
            pos.add(new Vector<Integer>());

        long[] count = new long[26];
        int[] enough = new int[26];

        while (true) {
            Arrays.fill(count, 0);
            Arrays.fill(enough, 0);
            for (int i = 0; i < 26; i++)
                pos.elementAt(i).clear();

            for (Integer j : positions) {
                int i = j + 1;
                if (i >= s.length())
                    break;
                int index = s.charAt(i) - 'a';
                count[index] += s.length() - i;
                pos.elementAt(index).add(i);
                enough[index]++;
            }

            if (k <= enough_last)
                break;
            else
                k -= enough_last;

            boolean changed = false;
            positions.clear();

            for (int i = 0; i < count.length; i++)
                if (k <= count[i]) {
                    positions.addAll(pos.elementAt(i));
                    changed = true;
                    enough_last = enough[i];
                    ans.append((char) ('a' + i));
                    break;
                } else
                    k -= count[i];

            if (!changed) {
                noline = true;
                break;
            }
        }

        out.println(noline ? "No such line." : ans);
        out.close();
    }
}

------------------------------


Write a python script that can generate test cases for a programming problem with the provided problem statement and solution codes. The test case should be focus on exhausting the code to get time limit exceeded and should follow the input format. The python script should be able to read an argument which specify a directory and write all the testcases as 'test_01.in', 'test_02.in', ... into the directory.