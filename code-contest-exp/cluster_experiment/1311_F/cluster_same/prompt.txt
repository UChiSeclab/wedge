Problem Statement
There are n points on a coordinate axis OX. The i-th point is located at the integer point x_i and has a speed v_i. It is guaranteed that no two points occupy the same coordinate. All n points move with the constant speed, the coordinate of the i-th point at the moment t (t can be non-integer) is calculated as x_i + t ⋅ v_i.

Consider two points i and j. Let d(i, j) be the minimum possible distance between these two points over any possible moments of time (even non-integer). It means that if two points i and j coincide at some moment, the value d(i, j) will be 0.

Your task is to calculate the value ∑_{1 ≤ i < j ≤ n} d(i, j) (the sum of minimum distances over all pairs of points).

Input

The first line of the input contains one integer n (2 ≤ n ≤ 2 ⋅ 10^5) — the number of points.

The second line of the input contains n integers x_1, x_2, ..., x_n (1 ≤ x_i ≤ 10^8), where x_i is the initial coordinate of the i-th point. It is guaranteed that all x_i are distinct.

The third line of the input contains n integers v_1, v_2, ..., v_n (-10^8 ≤ v_i ≤ 10^8), where v_i is the speed of the i-th point.

Output

Print one integer — the value ∑_{1 ≤ i < j ≤ n} d(i, j) (the sum of minimum distances over all pairs of points).

Examples

Input


3
1 3 2
-100 2 3


Output


3


Input


5
2 1 4 3 5
2 2 2 3 4


Output


19


Input


2
2 1
-3 0


Output


0
------------------------------
/* package codechef; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;




/* Name of the class has to be "Main" only if the class is public. */
public class p6
{
         static class Input {
        private StringTokenizer tokenizer = null;
        private BufferedReader reader;
 
        public Input(InputStream inputStream) {
            reader = new BufferedReader(new InputStreamReader(inputStream));
        }
 
        public String nextLine() {
            try {
                return reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException();
            }
        }
 
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                tokenizer = new StringTokenizer(nextLine());
            }
            return tokenizer.nextToken();
        }
 
        public int nextInt() {
            return Integer.parseInt(next());
        }
 
        public long nextLong() {
            return Long.parseLong(next());
        }
 
        public int[] nextIntArray(int n, int add) {
            int[] result = new int[n];
            for (int i = 0; i < n; i++) {
                result[i] = nextInt() + add;
            }
            return result;
        }
 
        public long[] nextLongArray(int n, long add) {
            long[] result = new long[n];
            for (int i = 0; i < n; i++) {
                result[i] = nextLong() + add;
            }
            return result;
        }
 
        public int[] nextIntArray(int n) {
            return nextIntArray(n, 0);
        }
 
    }

    static long get(long a[],int in)
    {
        long sum=0;
        while(in>0)
        {
            sum+=a[in];
            in-=in&(-in);
        }
        return sum;
    }

    static void upd(long a[],int in ,long val)
    {
        int n=a.length-1;
        while(in<=n)
        {
            a[in]+=val;
            in+=in&(-in);
        }
    }
static PrintWriter out=new PrintWriter(System.out);
    static int search(long a[],long e)
    {
        //out.println("ele"+e);
        int l=0,r=a.length-1,mid,ans=r;
        while(l<=r)
        {
            mid=(l+r)/2;
         //  out.println(l+" "+r+" "+a[mid]);
            if(a[mid]>=e)
            {
                ans=Math.min(ans,mid);
                r=mid-1;
            }
            else
            l=mid+1;
        }
       // out.println(ans);
        return ans;
    }
    
	public static void main (String[] args) throws java.lang.Exception
	{
		Input s=new Input(System.in);
		int t=1;
		
		
		while(t-->0)
		{
                int n=s.nextInt();
                int a[]=s.nextIntArray(n);
                int b[]=s.nextIntArray(n);

                myclass m1[]=new myclass[n];
                TreeSet<Integer> hs=new TreeSet<>();
                for(int i=0;i<n;i++)
                {
                    m1[i]=new myclass(a[i],b[i]);
                    hs.add(b[i]);
                }

                Arrays.sort(m1,new myclass());
                long c[]=new long[hs.size()];
                int i1=0;
                for(Integer el:hs)
                c[i1++]=el;
                long p1[]=new long[hs.size()+1];
                long p2[]=new long[hs.size()+1];
                long ans=0;
                for(int i=0;i<n;i++)
                {
                    int in=search(c,(long)m1[i].b);
                    //out.println(get(p1,in+1)+" "+get(p2,in+1));
                    ans+=get(p1,in+1)*(long)m1[i].a-get(p2,in+1);
                    upd(p1,in+1,1);
                    upd(p2,in+1,m1[i].a);
                   // out.println(m1[i].b+" "+ans+" "+in);
                }

                out.println(ans);

        }
        out.flush();
	}
}


class myclass implements Comparator<myclass>
{
    int a,b;
    myclass(int a,int b)
    {
        this.a=a;
        this.b=b;
    }
    myclass(){}

    public int compare(myclass m1,myclass m2)
    {
        if(m1.a!=m2.a)
        return m1.a-m2.a;
        else
        return m1.b-m2.b;
    }

}
------------------------------
import java.util.Arrays;
import java.util.Scanner;
import java.util.Comparator;
 
 
public class R624_F {
	private static long sum (long[] t, int pos) {
		long result = 0;
		while (pos >= 0) {
			result += t[pos];
			pos = (pos & (pos + 1)) - 1;
		}
		return result;
	}
	
	private static void upd (long[] t, int pos, int delta) {
		while (pos < t.length) {
			t[pos] += delta;
			pos = pos | (pos + 1);
		}
	}
	public static void main(String[] args) {
		Scanner in = new Scanner (System.in);
		int n = in.nextInt();
		int[][] p = new int[n][2];
		int[][] v = new int[n][2];
		
		for (int i = 0; i < n; i++)
			p[i][0] = in.nextInt();
		
		for (int i = 0; i < n; i++) {
			p[i][1] = in.nextInt();
			v[i][0] = p[i][1];
			v[i][1] = i;
		}
		in.close();
		
		Arrays.sort(v, new Comparator<int[]>() {
			public int compare(int[] a, int[] b) {
				return a[0] - b[0];
			}
		});
		int idx = 0;
		int[][] ret = new int[n][2];
		
		for (int i = 0; i < n; i++) {
			if (i > 0 && v[i][0] != v[i-1][0])
				idx++;
			ret[i][0] = idx;
			ret[i][1] = v[i][1];
		}
		Arrays.sort(ret, new Comparator<int[]>() {
			public int compare(int[] a, int[] b) {
				return a[1] - b[1];
			}
		});
		
		for (int i = 0; i < n; i++) {
			p[i][1] = ret[i][0];
		}
		Arrays.sort(p, new Comparator<int[]>() {
			public int compare(int[] a, int[] b) {
				return a[0] - b[0];
			}
		});
				
		long[] xs = new long[n];
		long[] cnt = new long[n];
		long ans = 0;
		
		for (int i = 0; i < n; i++) {
			int pos = p[i][1];
			ans += sum(cnt, pos) * p[i][0] - sum (xs, pos);
			upd(cnt, pos, 1);
			upd(xs, pos, p[i][0]);
		}
		System.out.println(ans);
 
	}
}
------------------------------

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.StringTokenizer;

public class Round624F {
	
	public static class node{
		int pos;
		int neg;
		long negsum;
		long possum;
		public node(int pos, int neg, long possum, long negsum) {
			this.pos = pos;
			this.neg = neg;
			this.negsum = negsum;
			this.possum = possum;
		}
	}
	
	public static node merge(node l, node r) {
		return new node(l.pos + r.pos, l.neg + r.neg, l.possum + r.possum, l.negsum + r.negsum);
	}

	public static void Update(node[] tree, int start, int end, int index, int i, int type, long speed) {
		if(start > end || i < start || i > end) {
			return;
		}
		if(start == end) {
			tree[index] = new node(type == 1? 1:0, type == -1? 1:0, type == 1 ? speed : 0, type == -1 ? speed : 0);
			return;
		}
		int mid = (start + end)>>1;
		Update(tree, start, mid, index<<1, i, type, speed);
		Update(tree, mid+1, end, index<<1|1, i, type, speed);
		tree[index] = merge(tree[index<<1], tree[index<<1|1]);
	}
	
	public static node Query(node[] tree, int start, int end, int index, int i, int j) {
		if(start > end || j < start || i > end) {
			return new node(0,0,0,0);
		}
		if(i <= start && j >= end) {
			return tree[index];
		}
		int mid = (start + end)>>1;
		node left = Query(tree, start, mid, index<<1, i, j);
		node right = Query(tree, mid + 1, end, index<<1|1, i , j);
		return merge(left, right);
	}
	
	public static class Pair implements Comparable<Pair>{
		int x;
		int v;
		public Pair(int x, int v) {
			this.x = x;
			this.v = v;
		}
		
		public int compareTo(Pair x) {
			return this.x - x.x;
		}
	}
	
	public static class Triple{
		int start;
		int end;
		int idx;
		public Triple(int start, int end, int idx) {
			this.start = start;
			this.end = end;
			this.idx = idx;
		}
	}
	
	public static void solve() {
		int n = s.nextInt();
		Pair[] points = new Pair[n];
		Pair[] reverse = new Pair[n];
		int[] xs = new int[n];
		for(int i = 0; i < n; i++) {
			xs[i] = s.nextInt();
		}
		int[] vs = new int[n];
		for(int i = 0; i < n; i++) {
			vs[i] = s.nextInt();
		}
		for(int i = 0; i < n; i++) {
			int x = xs[i], v = vs[i];
			points[i] = new Pair(x, v);
			reverse[i] = new Pair(Math.abs(v), Math.abs(v)==v?1:-1);
		}
		Arrays.sort(points);
		Arrays.sort(reverse);
		HashMap<Integer,Triple> helper = new HashMap<>();
		for(int i = 0; i < n; i++) {
			if(helper.containsKey(reverse[i].x)) {
				helper.get(reverse[i].x).end = i;
			}else {
				helper.put(reverse[i].x, new Triple(i, i, i));
			}
		}
		node[] tree = new node[4 * n + 1];
		Arrays.fill(tree, new node(0,0,0,0));
		long ans = 0;
		for(int i = 0; i < points.length; i++) {
			int v = points[i].v;
			int id = helper.get(Math.abs(v)).idx;
			helper.get(Math.abs(v)).idx++;
			int mid = helper.get(Math.abs(v)).end;
			int start = helper.get(Math.abs(v)).start;
			int end = helper.get(Math.abs(v)).end;
			node left = Query(tree, 0, n - 1, 1, 0, start - 1);
			node mid_ = Query(tree, 0, n - 1, 1 , start, end);
			node right = Query(tree, 0, n - 1, 1, mid + 1, n - 1);
			long val = points[i].x;
			if(Math.abs(v) == v) {
				ans += - left.possum + (long)left.pos * val;
				ans += - left.negsum + (long)left.neg * val;
				ans += - right.negsum + (long)right.neg * val;
				ans += -mid_.possum + (long)mid_.pos * val;
				ans += -mid_.negsum + (long)mid_.neg * val;
			}else {
				ans += - right.negsum + (long)right.neg * val;
				ans += - mid_.negsum + (long)mid_.neg * val;
			}
			Update(tree, 0, n - 1, 1, id, v < 0 ? -1 : 1, val);
		}
		out.println(ans);
	}

	public static void main(String[] args) {
		out = new PrintWriter(new BufferedOutputStream(System.out));
		s = new FastReader();
		solve();
		out.close();
	}

	public static FastReader s;
	public static PrintWriter out;

	public static class FastReader {
		BufferedReader br;
		StringTokenizer st;

		public FastReader() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		String next() {
			while (st == null || !st.hasMoreTokens()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		String nextLine() {
			String str = "";
			try {
				str = br.readLine();
			} catch (Exception e) {
				e.printStackTrace();
			}
			return str;
		}
	}

	
}

------------------------------
import java.util.*;
import java.io.*;

public class MovingPoints {

	public static void main(String[] args) {
		JS scan = new JS();
		int n = scan.nextInt();
		long[] xs = new long[n];
		int[] vs = new int[n];
		TreeSet<Integer> set = new TreeSet<Integer>();
		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
		for(int i = 0; i < n; i++) xs[i] = scan.nextLong();
		for(int i = 0; i < n; i++) {
			vs[i] = scan.nextInt();
			set.add(vs[i]);
		}
		int curr = 0;
		for(int i : set) map.put(i, curr++);
		BIT[][] b = new BIT[2][2];
		for(int i = 0; i < 2; i++)
			for(int j = 0; j < 2; j++)
				b[i][j] = new BIT(curr);
		Point[] pts = new Point[n];
		for(int i = 0; i < n; i++) 
			pts[i] = new Point(xs[i], map.get(vs[i]));
		Arrays.sort(pts);
		long ans = 0;
		for(int i = 0; i < n; i++) {
			long x = b[0][0].query(0, pts[i].v); // the sum
			long s = b[0][1].query(0, pts[i].v)*pts[i].x; // the count
			ans += s-x;
			b[0][0].update(pts[i].v, pts[i].x);
			b[0][1].update(pts[i].v, 1);
		}
//		for(int i = n-1; i >= 0; i--) {
//			long x = b[1][0].query(pts[i].v, curr-1);
//			long s = b[1][1].query(pts[i].v, curr-1)*pts[i].x; // the count
//			ans += x-s;
//			b[1][0].update(pts[i].v, pts[i].x);
//			b[1][1].update(pts[i].v, 1);
//		}
		System.out.println(ans);
	}
	
	static class Point implements Comparable<Point>{
		
		long x;
		int v;
		
		public Point(long x, int v) {
			this.x = x;
			this.v = v;
		}
		
		public int compareTo(Point o) {
			return Long.compare(this.x, o.x);
		}
	}

	static class BIT {
		int n;
		long[] tree;
		
		public BIT(int n) {
			this.n = n;
			tree = new long[n + 2];
		}
		
		long read(int i) {
			i++;
			long sum = 0;
			while (i > 0) {
				sum += tree[i];
				i -= i & -i;
			}
			return sum;
		}
		
		void update(int i, long val) {
			i++;
			while (i <= n) {
				tree[i] += val;
				i += i & -i;
			}
		}
		
		long query(int left, int right) { return read(right)-read(left-1); }
	}
 
	static class JS{
		public int BS = 1<<16;
		public char NC = (char)0;
		byte[] buf = new byte[BS];
		int bId = 0, size = 0;
		char c = NC;
		double num = 1;
		BufferedInputStream in;
 
		public JS() {
			in = new BufferedInputStream(System.in, BS);
		}
 
		public JS(String s) throws FileNotFoundException {
			in = new BufferedInputStream(new FileInputStream(new File(s)), BS);
		}
 
		public char nextChar(){
			while(bId==size) {
				try {
					size = in.read(buf);
				}catch(Exception e) {
					return NC;
				}				
				if(size==-1)return NC;
				bId=0;
			}
			return (char)buf[bId++];
		}
 
		public int nextInt() {
			return (int)nextLong();
		}
 
		public long nextLong() {
			num=1;
			boolean neg = false;
			if(c==NC)c=nextChar();
			for(;(c<'0' || c>'9'); c = nextChar()) {
				if(c=='-')neg=true;
			}
			long res = 0;
			for(; c>='0' && c <='9'; c=nextChar()) {
				res = (res<<3)+(res<<1)+c-'0';
				num*=10;
			}
			return neg?-res:res;
		}
 
		public double nextDouble() {
			double cur = nextLong();
			return c!='.' ? cur:cur+nextLong()/num;
		}
 
		public String next() {
			StringBuilder res = new StringBuilder();
			while(c<=32)c=nextChar();
			while(c>32) {
				res.append(c);
				c=nextChar();
			}
			return res.toString();
		}
 
		public String nextLine() {
			StringBuilder res = new StringBuilder();
			while(c<=32)c=nextChar();
			while(c!='\n') {
				res.append(c);
				c=nextChar();
			}
			return res.toString();
		}
 
		public boolean hasNext() {
			if(c>32)return true;
			while(true) {
				c=nextChar();
				if(c==NC)return false;
				else if(c>32)return true;
			}
		}
	}
}

------------------------------
/*package whatever //do not write package name here */

import java.io.*;
import java.util.*;

public class GFG {
    
    static StringBuffer str=new StringBuffer("");
    static int n;
    static Long v[];
    static int lower_bound(long val)
    {
        int l=0,r=v.length-1;
        int ans=-1;
        while(l<=r)
        {
            int mid=(l+r)>>>1;
            if(v[mid]>=val)
            {
                ans=mid;
                r=mid-1; 
            }
            else
                l=mid+1;
        } 
        return ans;
    }
    static class BIT
    {
        long bit[];
        int sz;
        BIT(int sz)
        {
          this.sz=sz;
          bit=new long[sz+1];
          Arrays.fill(bit,0);
        }
        void update(int inx,long val)
        {
            inx++;
            while(inx<=sz)
            {
                bit[inx]+=val;
                inx+=(inx&(-inx));
            }
        }
         long getSum(int inx)
        {
            inx++;
            long res=0;
            while(inx>0)
            {
                res+=bit[inx];
                inx-=(inx&(-inx));
            }
            return res;
        }
    }
    static class Pair implements Comparable<Pair>{
        long x,v;
        Pair(long x,long v)
        {
            this.x=x;
            this.v=v;
        }
        public int compareTo(Pair p)
        {
            return (int)(this.x-p.x);
        }
    }
    static Pair p[];
    static void solve()
    {
       Arrays.sort(p);
       Arrays.sort(v);
       long ans=0;
        BIT f1=new BIT(n);
        BIT f2=new BIT(n);
       for(int i=0;i<n;i++)
       {
          int inx=lower_bound(p[i].v);
          ans+=f1.getSum(inx)*p[i].x-f2.getSum(inx);
          f1.update(inx,1);
          f2.update(inx,p[i].x);
       }
       System.out.println(ans);
    }
	public static void main (String[] args) throws Exception {
		
		BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
		
		    n=Integer.parseInt(bf.readLine());
		    String s[]=bf.readLine().trim().split("\\s+");
		    p=new Pair[n];
		    v=new Long[n];
	        String s1[]=bf.readLine().trim().split("\\s+");
		    for(int i=0;i<n;i++)
		    {
		      p[i]=new Pair(Long.parseLong(s[i]),Long.parseLong(s1[i]));
		      v[i]=Long.parseLong(s1[i]);
		    }
            solve();
		
	}
}
------------------------------


Write a python script that can generate test cases for a programming problem with the provided problem statement and solution codes. The test case should be focus on exhausting the code to get time limit exceeded and should follow the input format. The python script should be able to read an argument which specify a directory and write all the testcases as 'test_01.in', 'test_02.in', ... into the directory.