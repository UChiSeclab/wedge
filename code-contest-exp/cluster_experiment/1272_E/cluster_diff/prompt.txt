Problem Statement
You are given an array a consisting of n integers. In one move, you can jump from the position i to the position i - a_i (if 1 ≤ i - a_i) or to the position i + a_i (if i + a_i ≤ n).

For each position i from 1 to n you want to know the minimum the number of moves required to reach any position j such that a_j has the opposite parity from a_i (i.e. if a_i is odd then a_j has to be even and vice versa).

Input

The first line of the input contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in a.

The second line of the input contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ n), where a_i is the i-th element of a.

Output

Print n integers d_1, d_2, ..., d_n, where d_i is the minimum the number of moves required to reach any position j such that a_j has the opposite parity from a_i (i.e. if a_i is odd then a_j has to be even and vice versa) or -1 if it is impossible to reach such a position.

Example

Input


10
4 5 7 6 7 5 4 4 6 4


Output


1 1 1 2 -1 1 1 3 1 1 
------------------------------

import java.util.*;
import java.lang.*;
import java.lang.reflect.Array;
import java.io.*;
import java.math.*;
import java.text.DecimalFormat;
public class Prac{     
    static class InputReader { 
        private final InputStream stream;
	private final byte[] buf = new byte[8192];
	private int curChar, snumChars;
 	public InputReader(InputStream st) {
            this.stream = st;
	} 
	public int read() {
            if (snumChars == -1)
	 	throw new InputMismatchException();
            if (curChar >= snumChars) {
		curChar = 0;
                try {
                    snumChars = stream.read(buf);
		} 
                catch (IOException e) {
                    throw new InputMismatchException();
           	}
		if (snumChars <= 0)
                    return -1;
            }
            return buf[curChar++];
	}
        public int ni() {
            int c = read();
            while (isSpaceChar(c)) {
               	c = read();
            }
            int sgn = 1;
            if (c == '-') {
		sgn = -1;
		c = read();
            }
            int res = 0;
            do {
		res *= 10;
		res += c - '0';
		c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
	} 
	public long nl() {
            int c = read();
            while (isSpaceChar(c)) {
            c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            do {
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
	} 
	public int[] nia(int n) {
            int a[] = new int[n];
            for (int i = 0; i < n; i++) {
		a[i] = ni();
            }
            return a;
	} 
	public String rs() {
            int c = read();
            while (isSpaceChar(c)) {
		c = read();
            }
            StringBuilder res = new StringBuilder();
            do {
		res.appendCodePoint(c);
                    c = read();
            } while (!isSpaceChar(c));
            return res.toString();
	}
	public String nextLine() {
            int c = read();
            while (isSpaceChar(c))
		c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isEndOfLine(c));
            return res.toString();
        } 
	public boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}
 
	private boolean isEndOfLine(int c) {
            return c == '\n' || c == '\r' || c == -1;
	} 
    }
    static PrintWriter w = new PrintWriter(System.out);
    static long mod=998244353L;
    public static class Key {
 
    private final int x;
    private final int y;
 
    public Key(int x, int y) {
        this.x = x;
        this.y = y;
    }
 
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Key)) return false;
        Key key = (Key) o;
        return x == key.x && y == key.y;
    }
 
    @Override
    public int hashCode() {
        int result = x;
        result = 31 * result + y;
        return result;
    }
 
}
    static int jump[],n,mov[];
    static boolean v[];
    static ArrayList<Integer> arr[],revarr[];   
    public static void main (String[] args)throws IOException{
        InputReader sc=new InputReader(System.in);
        n=sc.ni();
        mov=new int[n+1];
        Arrays.fill(mov,-1);
        v=new boolean[n+1];
        jump=new int[n+1];
        arr=new ArrayList[n+1];
        revarr=new ArrayList[n+1];
        for(int i=0;i<=n;i++){
            mov[i]=Integer.MAX_VALUE;
            arr[i]=new ArrayList<>();
            revarr[i]=new ArrayList<>();
        }
        for(int i=1;i<=n;i++){
            jump[i]=sc.ni();
            if(i+jump[i]<=n){
                arr[i].add(i+jump[i]);
                revarr[i+jump[i]].add(i);
            }
            if(i-jump[i]>0){
                arr[i].add(i-jump[i]);
                revarr[i-jump[i]].add(i);
            }
        }
        Queue<Integer> q=new LinkedList<>();
        for(int i=1;i<=n;i++){
            for(int j:arr[i]){
                if(jump[i]%2!=jump[j]%2){
                    mov[i]=1;
                    q.add(i);
                }
            }
        }
        while(!q.isEmpty()){
            int x=q.poll();
            for(int j:revarr[x]){
                if(mov[j]>mov[x]+1){
                    mov[j]=mov[x]+1;
                    q.add(j);
                }
                
            }
        }
        for(int i=1;i<=n;i++)w.print((mov[i]>=(int)1e7)?-1+" ":mov[i]+" ");
        w.println();
        w.close();
    }
}
------------------------------
import java.io.*;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Random;
import java.util.StringTokenizer;

public class E {

    public static void main(String[] args) {
        FastReader scan = new FastReader();
        PrintWriter out = new PrintWriter(System.out);
        Task solver = new Task();
        int t = 1;
        while (t --> 0) solver.solve(1, scan, out);
        out.close();
    }

    static class Task {
        static ArrayList<Integer>[] adj;
        static int n;
        static int[] a;
        static int[][] dist;
        static ArrayDeque<Integer> index = new ArrayDeque<>(), parity = new ArrayDeque<>();

        public void solve(int testNumber, FastReader scan, PrintWriter out) {
            n = scan.nextInt();
            a = new int[n];
            dist = new int[n][2];
            adj = new ArrayList[n];
            for(int i = 0; i < n; i++) {
                adj[i] = new ArrayList<>();
                dist[i][0] = dist[i][1] = -1;
            }
            for(int i = 0; i < n; i++) {
                a[i] = scan.nextInt();
                if(i+a[i] < n) adj[i+a[i]].add(i);
                if(i-a[i] >= 0) adj[i-a[i]].add(i);
                dist[i][a[i]%2] = 0;
                index.addLast(i);
                parity.addLast(a[i] %= 2);
            }
            while(!index.isEmpty()) {
                int curr = index.pollFirst(), p = parity.pollFirst();
                for(int i : adj[curr]) {
                    if(dist[i][p] == -1) {
                        dist[i][p] = dist[curr][p]+1;
                        index.addLast(i);
                        parity.addLast(p);
                    }
                }
            }
            for(int i = 0; i < n; i++) {
                out.print(dist[i][a[i]^1]);
                out.print(" ");
            }
        }
    }

    static void shuffle(int[] a) {
        Random get = new Random();
        for (int i = 0; i < a.length; i++) {
            int r = get.nextInt(a.length);
            int temp = a[i];
            a[i] = a[r];
            a[r] = temp;
        }
    }

    static void shuffle(long[] a) {
        Random get = new Random();
        for (int i = 0; i < a.length; i++) {
            int r = get.nextInt(a.length);
            long temp = a[i];
            a[i] = a[r];
            a[r] = temp;
        }
    }

    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        public FastReader(String s) throws FileNotFoundException {
            br = new BufferedReader(new FileReader(new File(s)));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = "";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}
------------------------------
import java.io.*;
import java.util.*;

public class F {

	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner();
		PrintWriter out = new PrintWriter(System.out);
		int n = sc.nextInt();
		int[] a = new int[n];
		ArrayList<Integer>[] from = new ArrayList[n];
		ArrayList<Integer>[] to = new ArrayList[n];
		for (int i = 0; i < n; i++) {
			to[i] = new ArrayList();
			from[i] = new ArrayList();
		}
		for (int i = 0; i < n; i++) {
			a[i] = sc.nextInt();
			int v = i + a[i];
			if (v < n) {
				from[v].add(i);
				to[i].add(v);
			}
			v = i - a[i];
			if (v >= 0) {
				from[v].add(i);
				to[i].add(v);

			}
		}
		Queue<Integer> q = new LinkedList();
		int[] ans = new int[n];
		Arrays.fill(ans, -1);
		for (int i = 0; i < n; i++)
			for (int j : to[i])
				if (a[j] % 2 != a[i] % 2) {
					q.add(i);
					ans[i] = 1;
				}
		while (!q.isEmpty()) {
			int u = q.poll();
			for (int v : from[u]) {
				if (ans[v] == -1) {
					ans[v] = ans[u] + 1;
					q.add(v);
				}
			}
		}
		for (int x : ans)
			out.print(x + " ");

		out.close();

	}

	static int gcd(int a, int b) {
		return b == 0 ? a : gcd(b, a % b);
	}

	static class Scanner {
		BufferedReader br;
		StringTokenizer st;

		Scanner() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		Scanner(String fileName) throws FileNotFoundException {
			br = new BufferedReader(new FileReader(fileName));
		}

		String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		String nextLine() throws IOException {
			return br.readLine();
		}

		int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		long nextLong() throws NumberFormatException, IOException {
			return Long.parseLong(next());
		}

		double nextDouble() throws NumberFormatException, IOException {
			return Double.parseDouble(next());
		}

		boolean ready() throws IOException {
			return br.ready();
		}

	}

	static void sort(int[] a) {
		shuffle(a);
		Arrays.sort(a);
	}

	static void shuffle(int[] a) {
		int n = a.length;
		Random rand = new Random();
		for (int i = 0; i < n; i++) {
			int tmpIdx = rand.nextInt(n);
			int tmp = a[i];
			a[i] = a[tmpIdx];
			a[tmpIdx] = tmp;
		}
	}

}
------------------------------

import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        ArrayList<Integer> values = new ArrayList<>();
        for(int i=0; i<n; i++) {
            values.add(sc.nextInt());
        }
        int[] best = new int[n];
        Queue<Integer> q = new LinkedList<>();
        Map<Integer, Set<Integer>> edges = new TreeMap<>();
        for(int i=0; i<n; i++) {
            if(i - values.get(i) >= 0) {
                if(edges.get(i-values.get(i)) == null) edges.put(i-values.get(i), new HashSet<>());
                edges.get(i-values.get(i)).add(i);
            }
            if(i + values.get(i) < n) {
                if(edges.get(i+values.get(i)) == null) edges.put(i+values.get(i), new HashSet<>());
                edges.get(i+values.get(i)).add(i);
            }
            if(i - values.get(i) >= 0 && ((values.get(i)%2) != (values.get(i - values.get(i))%2)) ) {
                best[i] = 1;
                q.add(i);
                continue;
            }
            if(i + values.get(i) < n && ((values.get(i)%2) != (values.get(i + values.get(i))%2))) {
                best[i] = 1;
                q.add(i);
                continue;
            }
        }
        while(!q.isEmpty()) {
            int curr = q.remove();
            if(edges.get(curr) == null) continue;
            for(int i : edges.get(curr)) {
                if(best[i] == 0) {
                    q.add(i);
                    best[i] = best[curr] + 1;
                }
            }
        }
        for(int i=0; i<n; i++) {
            if(best[i] == 0) System.out.print("-1 ");
            else System.out.print(best[i] + " ");
        }

    }

}

------------------------------
import java.io.*;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Scanner;

@SuppressWarnings("Duplicates")
public class ProblemE {

    public static void main(String[] args) throws IOException{
        //Reader sc = new Reader();
        PrintWriter pw = new PrintWriter(System.out);
        Scanner sc = new Scanner(System.in);
        //BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int numsNum = sc.nextInt();
        int[] nums = new int[numsNum];
        HashSet<Integer>[] canGo = new HashSet[numsNum];
        for (int i = 0; i < numsNum; i++) canGo[i] = new HashSet<>();
        for (int i = 0; i < numsNum; i++) {
            int aux = sc.nextInt();
            nums[i] = aux;
            if (i-aux>=0)canGo[i-aux].add(i);
            if (i+aux<numsNum)canGo[i+aux].add(i);
        }
        int[] sol = new int[numsNum];
        {
            boolean[] visited = new boolean[numsNum];
            LinkedList<Integer> que = new LinkedList<>();
            for (int i = 0; i < numsNum; i++) {
                if (nums[i]%2==0)continue;
                que.add(i);
                visited[i] = true;
            }
            que.add(null);
            int depth = 0;
            while (que.size() > 1){
                Integer aux = que.removeFirst();
                if (aux == null){
                    depth++;que.add(null);continue;
                }
                if (nums[aux]%2==0)sol[aux] = depth;
                for (Integer next : canGo[aux]) {
                    if (visited[next])continue;
                    que.add(next);
                    visited[next] = true;
                }
            }
        }
        {
            boolean[] visited = new boolean[numsNum];
            LinkedList<Integer> que = new LinkedList<>();
            for (int i = 0; i < numsNum; i++) {
                if (nums[i]%2==1)continue;
                que.add(i);
                visited[i] = true;
            }
            que.add(null);
            int depth = 0;
            while (que.size() > 1){
                Integer aux = que.removeFirst();
                if (aux == null){
                    depth++;que.add(null);continue;
                }
                if (nums[aux]%2==1)sol[aux] = depth;
                for (Integer next : canGo[aux]) {
                    if (visited[next])continue;
                    que.add(next);
                    visited[next] = true;
                }
            }
        }

        pw.print(sol[0]==0?-1:sol[0]);
        for (int i = 1; i < numsNum; i++) {
            pw.print(" ");
            pw.print(sol[i]==0?-1:sol[i]);
        }
        pw.println();


        pw.flush();
    }

    static class State {
        public int depth,from;
        public boolean even;

        public State(int depth, boolean even, int from) {
            this.depth = depth;
            this.even = even;
        }
    }


    static class Reader
    {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public Reader()
        {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public Reader(String file_name) throws IOException
        {
            din = new DataInputStream(new FileInputStream(file_name));
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public String readLine() throws IOException
        {
            byte[] buf = new byte[64]; // line length
            int cnt = 0, c;
            while ((c = read()) != -1)
            {
                if (c == '\n')
                    break;
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }

        public int nextInt() throws IOException
        {
            int ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }

        public long nextLong() throws IOException
        {
            long ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');
            if (neg)
                return -ret;
            return ret;
        }

        public double nextDouble() throws IOException
        {
            double ret = 0, div = 1;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();

            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');

            if (c == '.')
            {
                while ((c = read()) >= '0' && c <= '9')
                {
                    ret += (c - '0') / (div *= 10);
                }
            }

            if (neg)
                return -ret;
            return ret;
        }

        private void fillBuffer() throws IOException
        {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }

        private byte read() throws IOException
        {
            if (bufferPointer == bytesRead)
                fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException
        {
            if (din == null)
                return;
            din.close();
        }
    }
}

------------------------------


Write a python script that can generate test cases for a programming problem with the provided problem statement and solution codes. The test case should be focus on exhausting the code to get time limit exceeded and should follow the input format. The python script should be able to read an argument which specify a directory and write all the testcases as 'test_01.in', 'test_02.in', ... into the directory.