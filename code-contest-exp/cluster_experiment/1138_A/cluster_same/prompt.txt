Problem Statement
Arkady invited Anna for a dinner to a sushi restaurant. The restaurant is a bit unusual: it offers n pieces of sushi aligned in a row, and a customer has to choose a continuous subsegment of these sushi to buy.

The pieces of sushi are of two types: either with tuna or with eel. Let's denote the type of the i-th from the left sushi as t_i, where t_i = 1 means it is with tuna, and t_i = 2 means it is with eel.

Arkady does not like tuna, Anna does not like eel. Arkady wants to choose such a continuous subsegment of sushi that it has equal number of sushi of each type and each half of the subsegment has only sushi of one type. For example, subsegment [2, 2, 2, 1, 1, 1] is valid, but subsegment [1, 2, 1, 2, 1, 2] is not, because both halves contain both types of sushi.

Find the length of the longest continuous subsegment of sushi Arkady can buy.

Input

The first line contains a single integer n (2 ≤ n ≤ 100 000) — the number of pieces of sushi.

The second line contains n integers t_1, t_2, ..., t_n (t_i = 1, denoting a sushi with tuna or t_i = 2, denoting a sushi with eel), representing the types of sushi from left to right.

It is guaranteed that there is at least one piece of sushi of each type. Note that it means that there is at least one valid continuous segment.

Output

Print a single integer — the maximum length of a valid continuous segment.

Examples

Input


7
2 2 2 1 1 2 2


Output


4


Input


6
1 2 1 2 1 2


Output


2


Input


9
2 2 1 1 1 2 2 2 2


Output


6

Note

In the first example Arkady can choose the subsegment [2, 2, 1, 1] or the subsegment [1, 1, 2, 2] with length 4.

In the second example there is no way but to choose one of the subsegments [2, 1] or [1, 2] with length 2.

In the third example Arkady's best choice is the subsegment [1, 1, 1, 2, 2, 2].
------------------------------
import java.util.Scanner;
public class ProblemaCsecondtry 
{
private static long arr[];
 private static int arr1[];
 private static int arr2[];
 private static int length;
 static Scanner scan = new Scanner(System.in);
 private static int theBiggestMean;
 

 
	public static void main(String[] args) 
	{
		
		
		length = scan.nextInt();
		arr = new long [length];
		arr1 = new int [length+10];
		arr2 = new int [length+10];
		
		readMatrix();
		
		if(length==2)
		{
			System.out.println("2");
			System.exit(0);
		}
		getarr1();
		getarr2();
		
	
		int theOneWithZero = getTheOneWithZero();
		
		if(theOneWithZero==1) getTheLargestArr1();
		if(theOneWithZero==2) getTheLargestArr2();
		
		
		
	
			//System.out.println(theBiggestMean*2);
		
	
		
		  
		  int c=0;
	
		/*
		while(arr1[c]!=-1)
		{
			System.out.println("arr1: "+arr1[c]);
			c++;
		}
		
		
		System.out.println("\n\n");
		
		 c=0;
		
		while(arr2[c]!=-1)
		{
			System.out.println("Arr2: "+arr2[c]);
			c++;
		}
			*/
		
		
		System.out.println(theBiggestMean*2);
		
	}
	
	
	
	
	
	public static void readMatrix() 
	{
		for(int i = 0; i < length ; i++)
		{
			arr[i] = scan.nextInt();
		}
	}
	
	public static void getarr1()
	{
		
		int matrix1 = 0, matrix2 = 0 ;
	    int counter1=0,counter2=0;
		int flagtoSave=0;
		
		for(int i=0 ; i<length ; i++)
		{
			if(arr[i]==1)
			{
				flagtoSave=0;
				matrix1++;
			}
			else {
				if(flagtoSave==0) 
				{
					arr1[counter1]= matrix1;
					matrix1=0;
					flagtoSave=1;
					counter1++;
				}
			
			}
		}
		
	

		
		if(matrix1>0)
		{
			arr1[counter1]=matrix1;
			counter1++;
		}
		
		arr1[counter1]=-1;
		
		
	}

	public static void getarr2()
	{
		
		int matrix1 = 0, matrix2 = 0 ;
	    int counter1=0,counter2=0;
		int flagtoSave=0;
		
		for(int i=0 ; i<length ; i++)
		{
			if(arr[i]==2)
			{
				flagtoSave=0;
				matrix1++;
			}
			else {
				if(flagtoSave==0) 
				{
					arr2[counter1]= matrix1;
					matrix1=0;
					flagtoSave=1;
					counter1++;
				}
			
			}
		}
		


		
		if(matrix1>0)
		{
			arr2[counter1]=matrix1;
			counter1++;
		}
		
		arr2[counter1]=-1;
		
		
	}

	public static int getTheOneWithZero() 

	
	{
		/*
		 * El que tengaa el cero se comparará con uno hacia abajo
		 * Después preguntará si existe igual a él, si es así se compara. Esto antes que se llegué a -1
		*/
		
		//Identify who has 0
		
		int flag = 0;
		
		if(arr1[0]==0) flag=1;
		if(arr2[0]==0) flag=2;
		
		return flag;
		
		
		
		
		
	}
	
	public static void getTheLargestArr1()
	{
		
		
	
		int c=1;
		int tempMean=0;
		theBiggestMean=0;
		while(arr1[c] != -1)
		{
			//tempMean = ( arr1[c] + arr2[c-1] ) / 2;
			
			if(arr1[c]>arr2[c-1]) tempMean=arr2[c-1];
			else tempMean=arr1[c];
			
			if(theBiggestMean < tempMean)
			{
				theBiggestMean= tempMean;
			}
	
			
			if(arr2[c]!=-1)
			{
				//tempMean = ( arr1[c] + arr2[c] ) / 2;
				
				if(arr2[c]>arr1[c]) tempMean=arr1[c];
				else tempMean=arr2[c];
				
				if(theBiggestMean < tempMean)
				{
					theBiggestMean= tempMean;
				}
			}
			c++;
		}
		
		
	}
	
	public static void getTheLargestArr2()
	{
	
		
		int c=1;
		int tempMean=0;
		theBiggestMean=0;
		while(arr2[c] != -1)
		{
			//tempMean =( arr2[c] + arr1[c-1] ) / 2;
			
			if(arr2[c]>arr1[c-1]) tempMean=arr1[c-1];
			else tempMean=arr2[c];
			
			if(theBiggestMean < tempMean)
			{
				theBiggestMean= tempMean;
			}
	
			
			if(arr1[c]!=-1)
			{
				//tempMean = ( arr2[c] + arr1[c] ) / 2;
				
				if(arr2[c]>arr1[c]) tempMean=arr1[c];
				else tempMean=arr2[c];
				
				if(theBiggestMean < tempMean)
				{
					theBiggestMean = tempMean;
				}
			}
			c++;
		}
	}
	
}
------------------------------
import java.util.*;
public class riirt
{
	public static void main(String args[])
	{
		Scanner ob=new Scanner(System.in);
		int n=ob.nextInt();
		int a[]=new int[n];
		int i;
		int lc=1;
		int lp=0;
		int ans=0;
		for(i=0;i<n;i++)
		{
			a[i]=ob.nextInt();
		}
		int l=a[0];
		for(i=1;i<n;i++)
		{
			if(l!=a[i])
			{
				lp=lc;
				lc=1;
				if(lc>ans)
					ans=lc;
			}
			else
			{
				//System.out.println("ff");
				lc=lc+1;
				if(lc>ans)
					ans=Math.max(ans,Math.min(lc,lp));
			}
			l=a[i];
		}
		System.out.println(ans*2);
	}
}
------------------------------
import java.util.*;
import java.io.*;
public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()) {
			int n = sc.nextInt();
			int [] a = new int [n];
			for(int i=0;i<n;i++) {
				a[i]=sc.nextInt();
			}
			int temp = a[0];
			int max = 0;
			int [] b = new int [n];
			int k=0;
			for(int i=0;i<n;i++) {
				if(a[i]==temp) {
					b[k]++;
				}
				else {
					temp=a[i];
					k++;
					b[k]++;
				}
			}
			for(int i=0;i<k;i++) {
				if(s(b[i],b[i+1])>max) {
					max=s(b[i],b[i+1]);
				}
			}
			System.out.println(2*max);
		}
	}
	public static int s(int s1,int s2) {
		if(s1>s2) {
			return s2;
		}
		else {
			return s1;
		}
	}
}

------------------------------
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;

public class Main {
	public Main() {
		BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
		String[]temp ;
        String bfRead;
        try {
			bfRead = bf.readLine();
			temp=bfRead.split(" ");
			int n= Integer.parseInt(temp[0]);
			bfRead = bf.readLine();
			temp=bfRead.split(" ");
			int id=0;
			int cantidad=1;
			nodo cabeza=null;
			ArrayList<nodo> lista = new ArrayList<nodo>();
			for (int i = 0; i < n; i++) {
				if(i+1<temp.length && temp[i+1].equals(temp[i])) {
					cantidad++;
				}else {
					lista.add(new nodo(id, temp[i], cantidad));
					cantidad=1;
					id++;
				}
			}
			int mayor=0;
			for (int i = 0; i < lista.size(); i++) {
				if( i+1<lista.size() && !lista.get(i).tipo.equals(lista.get(i+1))) {
					if(lista.get(i).cantidad<=lista.get(i+1).cantidad &&  lista.get(i).cantidad>mayor) {
						mayor=lista.get(i).cantidad;
					}else if(lista.get(i+1).cantidad>mayor && lista.get(i+1).cantidad<=lista.get(i).cantidad) {
						mayor=lista.get(i+1).cantidad;
					}
				}
			}
			System.out.print(mayor*2);
			
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	
	public class nodo{
		int id;
		String tipo;
		int cantidad;

		
		public nodo(int id,String tipo,int cantidad){
			this.id=id;
			this.tipo=tipo;
			this.cantidad=cantidad;
		}

		public int getId() {
			return id;
		}

		public void setId(int id) {
			this.id = id;
		}

		public String getTipo() {
			return tipo;
		}

		public void setTipo(String tipo) {
			this.tipo = tipo;
		}

		public int getCantidad() {
			return cantidad;
		}

		public void setCantidad(int cantidad) {
			this.cantidad = cantidad;
		}

	}
	public static void main(String[] args) {
		
		Main m = new Main();	

	}
}
	   					  	 	 	 			  	     			
------------------------------
//package codeforces;
import java.util.Scanner;
import java.util.ArrayList;
public class ex5 {
public static void main(String[] args) {
	Scanner scan = new Scanner(System.in);
	int n = scan.nextInt();
	int[] arr = new int[n];
for (int i = 0; i < arr.length; i++) {
	arr[i]=scan.nextInt();
}
	
	ArrayList<Integer> list = new ArrayList<Integer>();
	int c1 = 0;
	int c2 = 0;
	
	for (int i = 0; i < n; i++) {
		
		if (arr[i] == 1) {
			c1++;
			if (c2 != 0) {
				list.add(c2);
				c2 = 0;
			}

		} else {
			c2++;
			if (c1 != 0) {
				list.add(c1);
				c1 = 0;
			}
		}
	}
	

	
	if (arr[n - 1] == 1) {
	list.add(c1);
	} else {
	
		list.add(c2);
	}
	

	
	int ele = arr[0];
	int ans = 0;
	
	for (int i = 1; i < list.size(); i++) {
		int temp1 = list.get(i - 1);
		
		int temp2 = list.get(i);
		int temp = Math.min(temp1, temp2);
		if(temp > ans) {
			ans = temp;
		}
	}
	System.out.println(ans*2);
}
}

------------------------------


Write a python script that can generate test cases for a programming problem with the provided problem statement and solution codes. The test case should be focus on exhausting the code to get time limit exceeded and should follow the input format. The python script should be able to read an argument which specify a directory and write all the testcases as 'test_01.in', 'test_02.in', ... into the directory.