Problem Statement
There are n boxers, the weight of the i-th boxer is a_i. Each of them can change the weight by no more than 1 before the competition (the weight cannot become equal to zero, that is, it must remain positive). Weight is always an integer number.

It is necessary to choose the largest boxing team in terms of the number of people, that all the boxers' weights in the team are different (i.e. unique).

Write a program that for given current values ​a_i will find the maximum possible number of boxers in a team.

It is possible that after some change the weight of some boxer is 150001 (but no more).

Input

The first line contains an integer n (1 ≤ n ≤ 150000) — the number of boxers. The next line contains n integers a_1, a_2, ..., a_n, where a_i (1 ≤ a_i ≤ 150000) is the weight of the i-th boxer.

Output

Print a single integer — the maximum possible number of people in a team.

Examples

Input

4
3 2 4 1


Output

4


Input

6
1 1 1 4 4 4


Output

5

Note

In the first example, boxers should not change their weights — you can just make a team out of all of them.

In the second example, one boxer with a weight of 1 can be increased by one (get the weight of 2), one boxer with a weight of 4 can be reduced by one, and the other can be increased by one (resulting the boxers with a weight of 3 and 5, respectively). Thus, you can get a team consisting of boxers with weights of 5, 4, 3, 2, 1.
------------------------------
import java.util.*;
import java.io.*;

public class CodeForces1203E {


    static BufferedReader f = new BufferedReader(new InputStreamReader(System.in));

    public static void main(String[] args) throws IOException {
        /*
        Idea:
        put all the numbers in an array (frequency array)
        for all elements in the array:
        if the frequency for i-1 is 0; i = i-1, do the same for i and i+1;
         */

        int numOfBoxers = Integer.parseInt(f.readLine());
        int[] freqArray = new int[150003];
        StringTokenizer tok = new StringTokenizer(f.readLine());
        for (int i = 0; i < numOfBoxers; i++) {
            freqArray[Integer.parseInt(tok.nextToken())]++;
        }

        for (int i = 1; i < freqArray.length - 1; i++) {
            if (freqArray[i] > 0) {
                if (freqArray[i] == 1) { //--one weight as hope the next term can compensate
                    if (i != 1 & freqArray[i - 1] == 0) {
                        freqArray[i - 1]++;
                        freqArray[i]--;
                    }
                    //stay
                } else if (freqArray[i] == 2) {
                    if (i != 1 & freqArray[i - 1] == 0) {
                        freqArray[i - 1]++;
                        freqArray[i]--;
                    } //the one behind is at least one, so i,i-1 are all covered
                    else {
                        freqArray[i + 1]++;
                        freqArray[i]--;
                    }//next add one so i, i+1 are all covered
                } else if (freqArray[i] >= 3) {
                    freqArray[i - 1]++;
                    freqArray[i + 1]++;
                    freqArray[i] -= 2;
                }


            }
        }

        int count = 0;
        for (int i = 1; i < 150002; i++) {
            if (freqArray[i] > 0) {
                count++;
            }
        }

        System.out.println(count);
        f.close();


    }

}

------------------------------

import java.io.*;
import java.util.Arrays;
import java.util.Collections;
import java.util.Scanner;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) {
        InputReader ir = new InputReader(new BufferedInputStream(System.in));
        int n = ir.nextInt();
        int[] mp = new int[150005];
        int[] a = new int[n];
        for(int i=0;i<n;i++){
            a[i] = ir.nextInt();
            mp[a[i]]++;
        }
        int count = 0;
        for(int i=1;i<150002;i++){
            if(mp[i-1] > 0 ){
                mp[i-1]--;
                count++;
            }else if(mp[i] > 0){
                mp[i]--;
                count++;
            }else if(mp[i+1] > 0){
                mp[i+1]--;
                count++;
            }
        }


        System.out.println(count);

    }
}

class InputReader {
    public BufferedReader reader;
    public StringTokenizer tokenizer;

    public InputReader(InputStream stream) {
        reader = new BufferedReader(new InputStreamReader(stream), 32768);
        tokenizer = null;
    }

    public String next() {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

}
------------------------------
import java.util.*;
import java.io.*;
import java.math.*;
public class Main
{
    public static void main(String args[])throws Exception
    {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw=new PrintWriter(System.out);
        int n=Integer.parseInt(br.readLine());
        int arr[]=new int[n];
        boolean vis[]=new boolean[150002];
        int cntr[]=new int[150002];
        String str[]=br.readLine().split(" ");
        for(int i=0;i<n;i++)
        {
            arr[i]=Integer.parseInt(str[i]);
            cntr[arr[i]]++;
        }
        int cnt=0;
        for(int i=1;i<=150000;i++)
        {
            if(cntr[i]==1)
            {
                if(i>1&&!vis[i-1])
                {
                    cnt+=1;
                    vis[i-1]=true;
                    continue;
                }
                if(!vis[i])
                {
                    cnt+=1;
                    vis[i]=true;
                    continue;
                }
                if(!vis[i+1])
                {
                    cnt+=1;
                    vis[i+1]=true;
                }
            }
            else if(cntr[i]>=2)
            {
                if(i>1&&cntr[i]>=1&&!vis[i-1])
                {
                    cnt+=1;
                    vis[i-1]=true;
                    cntr[i]-=1;
                }
                if(cntr[i]>=1&&!vis[i])
                {
                    cnt+=1;
                    vis[i]=true;
                    cntr[i]-=1;
                }
                if(cntr[i]>=1&&!vis[i+1])
                {
                    cnt+=1;
                    vis[i+1]=true;
                }
            }
        }
        
        /*Arrays.sort(arr);
        int cntr=0;
        for(int i=0;i<n;i++)
        {
            if(arr[i]>1&&!vis[arr[i]-1])
            {
                vis[arr[i]-1]=true;
                cntr++;
            }
            else if(!vis[arr[i]])
            {
                vis[arr[i]]=true;
                cntr++;
            }
            else if(!vis[arr[i]+1])
            {
                vis[arr[i]+1]=true;
                cntr++;
            }
        }*/
        pw.println(cnt);
        pw.flush();
        pw.close();
    }
}
------------------------------
import java.io.*;
import java.util.*;
import java.lang.*;
 
public class TestClass {
	private static Reader s;
	private static PrintWriter out;
	private final int delta = (int) 1e9 + 7;
 
	private static class Reader {
		final private int BUFFER_SIZE = 1 << 16;
		private DataInputStream din;
		private byte[] buffer;
		private int bufferPointer, bytesRead;
 
		public Reader() {
			din = new DataInputStream(System.in);
			buffer = new byte[BUFFER_SIZE];
			bufferPointer = bytesRead = 0;
		}
 
		public String readLine() throws IOException {
			byte[] buf = new byte[100000];
			int cnt = 0, c;
			while ((c = read()) != -1) {
				if (c == '\n')
					break;
				buf[cnt++] = (byte) c;
			}
			return new String(buf, 0, cnt);
		}
 
		public int nextInt() throws IOException {
			int ret = 0;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do {
				ret = ret * 10 + c - '0';
			} while ((c = read()) >= '0' && c <= '9');
 
			if (neg)
				return -ret;
			return ret;
		}
 
		public long nextLong() throws IOException {
			long ret = 0;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do {
				ret = ret * 10 + c - '0';
			} while ((c = read()) >= '0' && c <= '9');
			if (neg)
				return -ret;
			return ret;
		}
 
		public double nextDouble() throws IOException {
			double ret = 0, div = 1;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
 
			do {
				ret = ret * 10 + c - '0';
			} while ((c = read()) >= '0' && c <= '9');
 
			if (c == '.') {
				while ((c = read()) >= '0' && c <= '9') {
					ret += (c - '0') / (div *= 10);
				}
			}
 
			if (neg)
				return -ret;
			return ret;
		}
 
		private void fillBuffer() throws IOException {
			bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
			if (bytesRead == -1)
				buffer[0] = -1;
		}
 
		private byte read() throws IOException {
			if (bufferPointer == bytesRead)
				fillBuffer();
			return buffer[bufferPointer++];
		}
	}
 
	public static void main(String args[]) throws IOException {
		run();
	}
 
	private static void run() throws IOException {
		s = new Reader();
		out = new PrintWriter(System.out);
		solve();
		out.flush();
		out.close();
	}
 
	public static long gcd(long a, long b) {
		while (b > 0) {
			long c = a;
			a = b;
			b = c % b;
		}
		return a;
	}
 
 
	private static void solve() throws IOException {
		int n=s.nextInt(),t;
		int arr[]= new int[150002];
		int visited[]= new int[150002];
		visited[0]=1;
		for (int i=0;i<n;i++)
			arr[s.nextInt()]++;
 	
 		int count=0;
		
		for(int i=1;i<150002;i++)
		{
			if(arr[i]>0)
			{	
				if(visited[i-1]!=1)
				{	
					visited[i-1]++;
					arr[i]--;
					count++;
				}
				
				if(visited[i]!=1&&arr[i]>0)
				{
					visited[i]++;
					arr[i]--;
					count++;
				}
				
				if(visited[i+1]!=1&&arr[i]>0)
				{
					visited[i+1]++;
					count++;
				}

			}
		}
 		
		out.println(count);
 
	}
		
 
}
------------------------------
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author puneet
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastInput in = new FastInput(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskE solver = new TaskE();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskE {
        public void solve(int testNumber, FastInput in, PrintWriter out) {

            int n = in.ni();
            int[] arr = new int[150002];

            for (int i = 0; i < n; i++) {
                int num = in.ni();
                arr[num]++;
            }

            for (int i = 1; i <= 150001; i++) {
                if (arr[i] > 0 && arr[i - 1] == 0 && i != 1) {
                    arr[i - 1]++;
                    arr[i]--;
                }
                if (arr[i] > 1) {
                    arr[i + 1]++;
                    arr[i]--;
                }
            }

            long ans = 0;

            for (int i = 1; i <= 150001; i++) {
                if (arr[i] > 0) {
                    ans++;
                }
            }

            out.println(ans);
        }

    }

    static class FastInput {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private FastInput.SpaceCharFilter filter;

        public FastInput(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int ni() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}


------------------------------


Write a python script that can generate test cases for a programming problem with the provided problem statement and solution codes. The test case should be focus on exhausting the code to get time limit exceeded and should follow the input format. The python script should be able to read an argument which specify a directory and write all the testcases as 'test_01.in', 'test_02.in', ... into the directory.