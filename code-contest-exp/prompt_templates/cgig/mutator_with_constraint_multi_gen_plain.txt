Here is an example custom mutator provided in AFL++ repo:

{mutator_example}

Could you learn from it and generate a new one?

The constraints of input are described here:

-------- Problem begins

{problem_statement}

-------- Problem ends

Here are some example inputs that you can use as a reference:

{reference_inputs}

Here are the performance related conditions summarized by another LLM, e.g., `check_perf_condition_*(condition)`. These conditions are believed to be related to performance of the solution, i.e., when the conditions are satisfied, the solution will likely run slower than when they are not satisifed. Please learn from them so that the generated mutator can produce more inputs to satisfy the conditions so that the generated inputs can make the solution run slower.

-------- Constraints summary begins

{constraints_content}

-------- Constraints summary ends

Please note that:
1. You should ensure the mutated inputs follow the input constraints as much as possible. Note that 10000(10^5) is usually written as 105, 100000(10^6) is usually written as 106, etc.
2. You should implement an input generator and incorporate it in the mutator, so that each iteration it can randomly choose to mutate the last input or use the generator to generate inputs from scratch. Note that you should avoid using random generator with a large range of values when generating the size input (e.g., length of array, etc.), e.g., random.randint(1, 10000) (say 10000 is the upper bound), as it may not stress the program enough. Instead, use values that are more likely to cause inefficiencies, for example, values that are same or closer to the upper bound, like 10000, 9999, 9990 or random.randint(9900, 10000), etc. Feel free to directly use the upper bound as the size of the input. But for numbers that are not the size of the input, you may want to generate random values to improve the input diversity and cover different patterns.
3. You should try to implement multiple mutation operations that can be randomly selected. You can implement mutation operations that could potentially explore corner cases of the program (e.g., upper/lower bound).
4. You can add a try catch block to the mutation module so that if the mutation failed you can fall back to the generator since the generator is believed to be more robust.
